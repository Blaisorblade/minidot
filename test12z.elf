% echo "set unsafe true 
% loadFile test12z.elf" |/Volumes/Twelf\ for\ OS\ X\ \(Intel\)/Twelf/bin/twelf-server

% STLC: big step preservation
% - add store
% + add subtyping
% + add env to subtyping
% + add type members
% + add value members
% + add type bounds
% + add reflexivity for type selections
% + add subtyping to paths
% + add self types

%%%%%% work in progress %%%%%%

%% try to make extend-wf-tp require an upper bound %% 


%{ ------- arithmetic ----- }%

nat: type.
z: nat.
s: nat -> nat.

add : nat -> nat -> nat -> type.
add/z : add z N N.
add/s : add (s N1) N2 (s N3)
   <- add N1 N2 N3.

%mode add +N1 +N2 -N3.

lte : nat -> nat -> type.
lte/z : lte z N.
lte/s : lte (s N1) (s N2) 
   <- lte N1 N2.

%mode lte +N1 +N2.


eq : nat -> nat -> type.
eq/z : eq z z.
eq/s : eq (s N1) (s N2) 
   <- eq N1 N2.

% %mode eq +N1 +N2.


ne : nat -> nat -> type.
ne/z : ne z (s N).
ne/z : ne (s N) z.
ne/s : ne (s N1) (s N2) 
   <- ne N1 N2.

%mode ne +N1 +N2.


%query 0 * lte (s (s z)) (s z).
%query 1 * lte (s (s z)) (s (s z)).

eq-refl: {N:nat} eq N N -> type.
%mode eq-refl +N -E1.

- : eq-refl z eq/z.
- : eq-refl (s N) (eq/s E) <- eq-refl N E.

%worlds () (eq-refl _ _).
%total {A} (eq-refl A _).


sub-eq: eq A1 A2 -> eq C1 C2 -> add A1 B1 C1 -> add A2 B2 C2 -> eq B1 B2 -> type.
%mode sub-eq +E1 +E2 +A1 +A2 -E3.

- : sub-eq eq/z E add/z add/z E.
- : sub-eq (eq/s E1) (eq/s E2) (add/s A1) (add/s A2) E3
  <- sub-eq E1 E2 A1 A2 E3.

%worlds () (sub-eq _ _ _ _ _).
%total {A} (sub-eq A _ _ _ _).

add-inc: add A B C -> add A (s B) (s C) -> type.
%mode add-inc +E1 -E2.

- : add-inc add/z add/z.
- : add-inc (add/s A1) (add/s A2)
  <- add-inc A1 A2.

%worlds () (add-inc _ _).
%total {A} (add-inc A _).





%{ ------- language ----- }%

% sorts
cst: type.
op: type.

exp: type.

tpe: type.
val: type.

venv: type.
tenv: type.


% constants
ncst: nat -> cst.
fcst: cst.
tcst: cst.

% operators
plus  : op.
equal : op.

% expressions
cste: cst -> exp.
var: nat -> exp.
prm: op -> exp -> exp -> exp.
fun: exp -> exp -> tpe -> tpe -> exp.
app: exp -> exp -> exp.
sel: exp -> exp.


% types
int  : tpe.
bool : tpe.
top  : tpe.
bot  : tpe.
arrow: tpe -> tpe -> tpe.  % { A => B }
rect : tpe -> tpe -> tpe.  % { type A..B }
recv : tpe -> tpe.         % { val get: A }
tsel : exp -> tpe.         % x.A

% bind : nat -> tpe -> tpe.     % { this => A } %% we shouldn't need the nat param

bindh : (exp -> tpe) -> tpe.  % { this => A } hoas version


% values
cstv: cst -> val.
clos: exp -> val -> venv -> val.

% environments
vnil  : venv.
vcons : val -> venv -> venv.
tnil  : tenv.
tcons : tpe -> tenv -> tenv.






%{ ------- eval-op / primitives ----- }%

% typeof

typeof     : cst -> tpe -> type.
-/n        : typeof (ncst N) int.
-/t        : typeof (tcst) bool.
-/f        : typeof (fcst) bool.

%mode typeof *A *B.

% eval-op

eval-cst-op : op -> cst -> cst -> cst -> type.
e/plus     : eval-cst-op plus (ncst N1) (ncst N2) (ncst N3) <- add N1 N2 N3.
e/eqt      : eval-cst-op equal (ncst N1) (ncst N2) (tcst) <- lte N1 N2 <- lte N2 N1.
e/eqf      : eval-cst-op equal (ncst N1) (ncst N2) (fcst) <- ne N1 N2.

eval-op    : op -> val -> val -> val -> type.
ev/v       : eval-op O (cstv C1) (cstv C2) (cstv C3) <- eval-cst-op O C1 C2 C3.

%mode eval-cst-op +O +V1 +V2 -V3.
%mode eval-op +O +V1 +V2 -V3.


% type-op

type-op    : op -> tpe -> tpe -> tpe -> type.
t/plus     : type-op plus int int int.
t/eq       : type-op equal int int bool.


% eval-cst-op/safe

eval-cst-op-safe : type-op OP T1 T2 T3 -> eval-cst-op OP C1 C2 C3 -> typeof C3 T3 -> type.
%mode eval-cst-op-safe +LTE1 +LTE2 -LTE3.

-plus   : eval-cst-op-safe t/plus (e/plus _) -/n.
-eqt    : eval-cst-op-safe t/eq (e/eqt _ _) -/t.
-eqf    : eval-cst-op-safe t/eq (e/eqf _) -/f.

%worlds () (eval-cst-op-safe _ _ _).
%total LTE1 (eval-cst-op-safe LTE1 _ _). % induction on first arg (not used here)



%{ ------- environments ----- }%

vlookup-zero : venv -> exp -> val -> type.
vl/hit  : vlookup-zero (vcons V G) (var z) V.
vl/miss : vlookup-zero (vcons _ G) (var (s N)) V <- vlookup-zero G (var N) V.

vbind : venv -> val -> exp -> venv -> type.
vl/n  : vbind vnil V (var z) (vcons V vnil).
vl/c  : vbind (vcons V G1) V2 (var (s N)) (vcons V2 (vcons V G1)) <- vbind G1 V (var N) _.

vsize : venv -> exp -> type.
vf/n   : vsize vnil (var z).
vf/c   : vsize (vcons _ G) (var (s N)) <- vsize G (var N).

vlookup: venv -> exp -> val -> type.
vl  : vlookup G (var N) V
  <- vsize G (var S)
  <- add N M S
  <- vlookup-zero G (var M) V.


tlookup-zero: tenv -> exp -> tpe -> type.
tl/hit  : tlookup-zero (tcons V G) (var z) V.
tl/miss : tlookup-zero (tcons _ G) (var (s N)) V <- tlookup-zero G (var N) V.

tbind : tenv -> tpe -> exp -> tenv -> type.
tl/n  : tbind tnil V (var z) (tcons V tnil).
tl/c  : tbind (tcons V G1) V2 (var (s N)) (tcons V2 (tcons V G1)) <- tbind G1 V (var N) _.

tsize : tenv -> exp -> type.
tf/n   : tsize tnil (var z).
tf/c   : tsize (tcons _ G) (var (s N)) <- tsize G (var N).

%worlds () (tsize _ _).

tlookup: tenv -> exp -> tpe -> type.
tl  : tlookup G (var N) V
  <- tsize G (var S)
  <- add N M S
  <- tlookup-zero G (var M) V.

% tlookupa: tenv -> exp -> tpe -> type.
% tl/hita  : tlookupa (tcons V G) (var N) V <- tfresh G (var N).
% tl/missa : tlookupa (tcons _ G) (var N) V <- tlookupa G (var N) V.



% Partial ordering on environments

sub-env: tenv -> tenv -> type.

sub-env/refl: sub-env G G.
sub-env/ext: sub-env G1 (tcons Z G2) <- sub-env G1 G2.


sub-env-trans: sub-env G1 G2 -> sub-env G2 G3 -> sub-env G1 G3 -> type.
%mode sub-env-trans +A +B -C.

- : sub-env-trans S sub-env/refl S.
- : sub-env-trans S1 (sub-env/ext S2) (sub-env/ext S3) <- sub-env-trans S1 S2 S3.

%worlds () (sub-env-trans _ _ _).
%total A (sub-env-trans _ A _).


minmax-env: tenv -> tenv -> tenv -> tenv -> type.
mm-env/1: minmax-env G1 G2 G1 G2 <- sub-env G1 G2.
mm-env/2: minmax-env G1 G2 G2 G1 <- sub-env G2 G1.


% Diamond / common prefix property

sub-env-dia: sub-env G1 GT -> sub-env G2 GT -> minmax-env G1 G2 GS GU -> type.
%mode sub-env-dia +A +B -C.

- : sub-env-dia sub-env/refl S (mm-env/2 S).
- : sub-env-dia (sub-env/ext S1) sub-env/refl (mm-env/1 (sub-env/ext S1)).
- : sub-env-dia (sub-env/ext S1) (sub-env/ext S2) MM <- sub-env-dia S1 S2 MM.

%worlds () (sub-env-dia _ _ _).
%total A (sub-env-dia A _ _).



%{ ------- alpha conversion for types ------ }%

swap-nat: nat -> nat -> nat -> nat -> type.
- : swap-nat A A B B.
- : swap-nat B A B A.
- : swap-nat N A B N <- ne N A <- ne N B.



swapv-tp: tpe -> nat -> nat -> tpe -> type.

swapv-tp/int  : swapv-tp int N1 N2 int.
swapv-tp/bool : swapv-tp bool N1 N2 bool.
swapv-tp/top  : swapv-tp top N1 N2 top.
swapv-tp/bot  : swapv-tp bool N1 N2 bot.
swapv-tp/fun  : swapv-tp (arrow T1 T2) N1 N2 (arrow T1' T2')
                <- swapv-tp T1 N1 N2 T1'
                <- swapv-tp T2 N1 N2 T2'.
swapv-tp/rect : swapv-tp (rect T1 T2) N1 N2 (rect T1' T2')
                <- swapv-tp T1 N1 N2 T1'
                <- swapv-tp T2 N1 N2 T2'.
swapv-tp/recv : swapv-tp (recv T1) N1 N2 (recv T1')
                <- swapv-tp T1 N1 N2 T1'.
swapv-tp/tsel : swapv-tp (tsel (var N)) N1 N2 (tsel (var N')) 
                <- swap-nat N N1 N2 N'.
% swapv-tp/bind : swapv-tp (bind N T) N1 N2 (bind N' T')
%                <- swap-nat N N1 N2 N'
%                <- swapv-tp T N1 N2 T'.
swapv-tp/bindh : swapv-tp (bindh F) N1 N2 (bindh F')
                  <- swapv-tp (F (var N1)) N1 N2 (F' (var N2)).


swapv-env: tenv -> nat -> nat -> tenv -> type.

%% TODO



%{ ------- subtyping ------ }%

path-eval: tenv -> exp -> tpe -> type.

wf-tp : tenv -> tpe -> type.

sub-tp : tenv -> tpe -> tenv -> tpe -> type.

pev  : path-eval G E T <- wf-tp G T <- tlookup G E T.


sub-tp/int  : sub-tp G1 int G2 int.
sub-tp/bool : sub-tp G1 bool G2 bool.
sub-tp/top  : sub-tp G1 T G2 top <- wf-tp G1 T.
sub-tp/bot  : sub-tp G1 bot G2 T <- wf-tp G2 T.

sub-tp/fun  : sub-tp G1 (arrow T1 T2) G2 (arrow T3 T4)
              <- sub-tp G2 T3 G1 T1
              <- sub-tp G1 T2 G2 T4.

sub-tp/rect : sub-tp G1 (rect T1 T2) G2 (rect T3 T4)
              <- sub-tp G1 T1 G1 T2
              <- sub-tp G2 T3 G2 T4

              <- sub-tp G2 T3 G1 T1
              <- sub-tp G1 T2 G2 T4.

sub-tp/recv : sub-tp G1 (recv T1) G2 (recv T2)
              <- sub-tp G1 T1 G2 T2.

sub-tp/tsel1 : sub-tp G1 (tsel E1) G2 T2
              <- path-eval G1 E1 (rect T1 T1U)
              <- sub-tp G1 T1U G2 T2.

sub-tp/tsel2 : sub-tp G1 T1 G2 (tsel E2)
              <- path-eval G2 E2 (rect T2 T2U)
              <- sub-tp G1 T1 G2 T2.

sub-tp/tselx : sub-tp G1 (tsel E) G2 (tsel E)
              <- sub-env G G2
              <- sub-env G G1
              <- path-eval G E (rect T2 T2U)
              <- sub-tp G2 (rect T2 T2U) G1 (rect T2 T2U)
              <- sub-tp G1 (rect T2 T2U) G2 (rect T2 T2U).

sub-tp/tbindh : sub-tp G1 T1 G2 (bindh F)
               <- wf-tp G0 (bindh F)
               <- sub-tp G1 T1 (tcons T1' G0) (F (var N))
               <- sub-tp G1 T1 G1' T1'  %% built-in slack to fix transitivity (?)
               <- tsize G0 (var N)
               <- sub-env G0 G2.



wf-tp/int  : wf-tp G1 int.
wf-tp/bool : wf-tp G1 bool.
wf-tp/top  : wf-tp G1 top.
wf-tp/bot  : wf-tp G1 bot.

wf-tp/fun  : wf-tp G1 (arrow T1 T2)
              <- wf-tp G1 T1
              <- wf-tp G1 T2.

wf-tp/rect : wf-tp G1 (rect T1 T2)
              <- wf-tp G1 T1
              <- wf-tp G1 T2
              <- sub-tp G1 T1 G1 T2. % T1 <: T2 required for transitivity

wf-tp/recv : wf-tp G1 (recv T1)
              <- wf-tp G1 T1.

wf-tp/tsel : wf-tp G1 (tsel E1)
              <- path-eval G1 E1 (rect T1 T1U).

% wf-tp/tbind : wf-tp G1 (bind X T)
%              <- wf-tp (tcons (bind X T) G1) T'
%              <- swapv-tp T X (s N) T'
%              <- tsize G1 (var N).

wf-tp/tbindh : wf-tp G1 (bindh ([x] F x))
              <- wf-tp (tcons (bindh ([x] F x)) G0) (F (var N))
              <- tsize G0 (var N)
              <- sub-env G0 G1.





% Subtyping with explicit equality case

subeq-tp : tenv -> tpe -> tenv -> tpe -> type.

% subeq-tp/eq  : subeq-tp G1 T G2 T <- wf-tp G T <- sub-env G G1 <- sub-env G G2.
subeq-tp/sub : subeq-tp G1 T1 G2 T2 <- sub-tp G1 T1 G2 T2.





% Extending environments preserves lookup


extend-wf-lkpz: tlookup-zero G (var N) T -> {Z: tpe} tlookup-zero (tcons Z G) (var (s N)) T -> type.
%mode extend-wf-lkpz +A +B -D.
- : extend-wf-lkpz tl/hit _ (tl/miss tl/hit).
- : extend-wf-lkpz (tl/miss A) _ (tl/miss B) <- extend-wf-lkpz A _ B.
%worlds () (extend-wf-lkpz _ _ _).
%total A (extend-wf-lkpz A _ _).

size-inc: tsize G (var N) -> {Z: tpe} tsize (tcons Z G) (var (s N)) -> type.
%mode size-inc +A +B -D.
- : size-inc tf/n T (tf/c tf/n).
- : size-inc (tf/c S) T (tf/c S') <- size-inc S _ S'.
%worlds () (size-inc _ _ _).
%total A (size-inc A _ _).



extend-wf-lkp: tlookup G (var N) T -> {Z: tpe} tlookup (tcons Z G) (var N) T -> type.
%mode extend-wf-lkp +A +B -C.
- : extend-wf-lkp (tl L A S) Z (tl L' A' S')
      <- size-inc S Z S'
      <- add-inc A A'
      <- extend-wf-lkpz L Z L'.
%worlds () (extend-wf-lkp _ _ _).
%total A (extend-wf-lkp A _ _).


extend-wf-lkp-mult: tlookup G (var N) T -> sub-env G G1 -> tlookup G1 (var N) T -> type.
%mode extend-wf-lkp-mult +A +B -C.
- : extend-wf-lkp-mult L sub-env/refl L.
- : extend-wf-lkp-mult L (sub-env/ext S) L2
    <- extend-wf-lkp-mult L S L1
    <- extend-wf-lkp L1 _ L2.
%worlds () (extend-wf-lkp-mult _ _ _).
%total A (extend-wf-lkp-mult _ A _).






% Uniqueness of lookup

same: tpe -> tpe -> type.
ident: same T T.

% same-refl: same T1 T2 -> same T2 T1 -> type

lookup-zero-same: tlookup-zero G2 E T1 -> tlookup-zero G2 E T2 -> same T1 T2 -> type.
%mode lookup-zero-same +P1 +P2 -SBT.

- : lookup-zero-same tl/hit tl/hit ident.
- : lookup-zero-same (tl/miss A) (tl/miss B) X <- lookup-zero-same A B X.

%worlds () (lookup-zero-same _ _ _).
%total {T2} (lookup-zero-same T2 _ _).



size-eq: tsize G2 (var N1) -> tsize G2 (var N2) -> eq N1 N2 -> type.
%mode size-eq +P1 +P2 -SBT.

- : size-eq tf/n tf/n eq/z.
- : size-eq (tf/c A) (tf/c B) (eq/s X) <- size-eq A B X.

%worlds () (size-eq _ _ _).
%total {T2} (size-eq T2 _ _).



lookup-zero-eq: tlookup-zero G2 (var N1) (rect T1 T3) -> tlookup-zero G2 (var N2) (rect T2 T4) -> eq N1 N2 
  -> same T1 T2 -> same T3 T4 -> type.
%mode lookup-zero-eq +P1 +P2 +E -SBT -SBT2.

- : lookup-zero-eq tl/hit tl/hit eq/z ident ident.
- : lookup-zero-eq (tl/miss A) (tl/miss B) (eq/s E) X Y <- lookup-zero-eq A B E X Y.

%worlds () (lookup-zero-eq _ _ _ _ _).
%total {T2} (lookup-zero-eq T2 _ _ _ _).


lookup-eq: tlookup G2 (var N1) (rect T1 T3) -> tlookup G2 (var N2) (rect T2 T4) -> eq N1 N2
  -> same T1 T2 -> same T3 T4 -> type.
%mode lookup-eq +P1 +P2 +E -SBT -SBT.

- : lookup-eq (tl L1 A1 F1) (tl L2 A2 F2) EN X Y
        <- size-eq F1 F2 ES 
        <- sub-eq EN ES A1 A2 EM 
        <- lookup-zero-eq L1 L2 EM X Y.

%worlds () (lookup-eq _ _ _ _ _).
%total {T2} (lookup-eq T2 _ _ _ _).

eq-rect: same T1 T1' -> same T2 T2' -> same (rect T1 T2) (rect T1' T2') -> same (rect T1' T2') (rect T1 T2) -> type.
%mode eq-rect +P1 +P2 -SBT -SBT2.

- : eq-rect ident ident ident ident.

%worlds () (eq-rect _ _ _ _).
%total {T2} (eq-rect T2 _ _ _).



eq-low: same T1 T1' -> sub-tp G1 T1 G2 T2 -> sub-tp G1 T1' G2 T2 -> type.
%mode eq-low +P1 +P2 -SBT.

- : eq-low ident S S.

%worlds () (eq-low _ _ _).
%total {T2} (eq-low T2 _ _).
%reduces N3 <= N2 (eq-low _ N2  N3).


eq-high: same T2 T2' -> sub-tp G1 T1 G2 T2 -> sub-tp G1 T1 G2 T2' -> type.
%mode eq-high +P1 +P2 -SBT.

- : eq-high ident S S.

%worlds () (eq-high _ _ _).
%total {T2} (eq-high T2 _ _).
%reduces N3 <= N2 (eq-high _ N2  N3).

eq-wf: same T1 T1' -> wf-tp G1 T1 -> wf-tp G1 T1' -> type.
%mode eq-wf +P1 +P2 -SBT.

- : eq-wf ident S S.

%worlds () (eq-wf _ _ _).
%total {T2} (eq-wf T2 _ _).
%reduces N3 <= N2 (eq-wf _ N2  N3).

eq-pev: same T1 T1' -> path-eval G1 N T1 -> path-eval G1 N T1' -> type.
%mode eq-pev +P1 +P2 -SBT.

- : eq-pev ident S S.

%worlds () (eq-pev _ _ _).
%total {T2} (eq-pev T2 _ _).
%reduces N3 <= N2 (eq-pev _ N2  N3).






% Extending environments preserves subtyping

extend-wf-tp: wf-tp G1 T1 -> {Z: tpe} wf-tp (tcons Z G1) T1 -> type.
%mode extend-wf-tp +A +B -C.

extend-wf-pev : path-eval G1 E T1 -> {Z: tpe} path-eval (tcons Z G1) E T1 -> type.
%mode extend-wf-pev +A +B -C.



extend-sub-tp: sub-tp G1 T1 G2 T2 -> {Z: tpe} 
  sub-tp (tcons Z G1) T1 (tcons Z G2) T2 -> 
  sub-tp (tcons Z G1) T1 G2 T2 -> 
  sub-tp G1 T1 (tcons Z G2) T2 -> 
  type.
%mode extend-sub-tp +A +B -C -D -E.


- : extend-wf-pev (pev L W) T (pev L1 W1)
      <- extend-wf-tp W T W1
      <- extend-wf-lkp L T L1.



- : extend-wf-tp wf-tp/int T wf-tp/int.
- : extend-wf-tp wf-tp/bool T wf-tp/bool.
- : extend-wf-tp wf-tp/top T wf-tp/top.
- : extend-wf-tp wf-tp/bot T wf-tp/bot.
- : extend-wf-tp (wf-tp/fun W1 W2) T (wf-tp/fun W1' W2') 
      <- extend-wf-tp W1 _ W1'
      <- extend-wf-tp W2 _ W2'.
- : extend-wf-tp (wf-tp/rect ST W1 W2) T (wf-tp/rect ST' W1' W2') 
      <- extend-sub-tp ST _ ST' _ _
      <- extend-wf-tp W1 _ W1'
      <- extend-wf-tp W2 _ W2'.
- : extend-wf-tp (wf-tp/recv W1) T (wf-tp/recv W1') 
      <- extend-wf-tp W1 _ W1'.
- : extend-wf-tp (wf-tp/tsel P) T (wf-tp/tsel P1)
      <- extend-wf-pev P T P1.

% - : extend-wf-tp (wf-tp/tbind S X W) T (wf-tp/tbind (tf/c S) X' W')
%       <- extend-wf-tp W _ W1
%       <- extend-swap-wf-tp W1 X S W' X'.

- : extend-wf-tp (wf-tp/tbindh SE S W) T (wf-tp/tbindh (sub-env/ext SE) S W).

- : extend-sub-tp sub-tp/int T sub-tp/int sub-tp/int sub-tp/int.
- : extend-sub-tp sub-tp/bool T sub-tp/bool sub-tp/bool sub-tp/bool.
- : extend-sub-tp (sub-tp/top ST) T (sub-tp/top ST') (sub-tp/top ST') (sub-tp/top ST) 
      <- extend-wf-tp ST _ ST'.
- : extend-sub-tp (sub-tp/bot ST) T (sub-tp/bot ST') (sub-tp/bot ST) (sub-tp/bot ST') 
      <- extend-wf-tp ST _ ST'.
- : extend-sub-tp (sub-tp/fun ST1 ST2) T (sub-tp/fun ST1' ST2') (sub-tp/fun ST1A ST2B) (sub-tp/fun ST1B ST2A)
      <- extend-sub-tp ST1 _ ST1' ST1A ST1B
      <- extend-sub-tp ST2 _ ST2' ST2A ST2B.
- : extend-sub-tp (sub-tp/rect ST1 ST2 B2 B1) T (sub-tp/rect ST1' ST2' B2' B1') (sub-tp/rect ST1A ST2B B2 B1') (sub-tp/rect ST1B ST2A B2' B1) 
      <- extend-sub-tp B2 _ B2' _ _
      <- extend-sub-tp B1 _ B1' _ _
      <- extend-sub-tp ST1 _ ST1' ST1A ST1B
      <- extend-sub-tp ST2 _ ST2' ST2A ST2B.
- : extend-sub-tp (sub-tp/recv ST1) T (sub-tp/recv ST1') (sub-tp/recv ST1A) (sub-tp/recv ST1B) 
      <- extend-sub-tp ST1 _ ST1' ST1A ST1B.
- : extend-sub-tp (sub-tp/tsel1 ST P) T 
    (sub-tp/tsel1 ST' P') (sub-tp/tsel1 STA P') (sub-tp/tsel1 STB P)
      <- extend-wf-pev P _ P'
      <- extend-sub-tp ST _ ST' STA STB.
- : extend-sub-tp (sub-tp/tsel2 ST P) T 
    (sub-tp/tsel2 ST' P') (sub-tp/tsel2 STA P) (sub-tp/tsel2 STB P')
      <- extend-wf-pev P _ P'
      <- extend-sub-tp ST _ ST' STA STB.

- : extend-sub-tp (sub-tp/tselx ST ST2 P S1 S2) T 
    (sub-tp/tselx ST' ST2' P (sub-env/ext S1) (sub-env/ext S2)) 
    (sub-tp/tselx STA ST2B P (sub-env/ext S1) S2) 
    (sub-tp/tselx STB ST2A P S1 (sub-env/ext S2))
      <- extend-sub-tp ST _ ST' STA STB
      <- extend-sub-tp ST2 _ ST2' ST2A ST2B.

% - : extend-sub-tp (sub-tp/tbind1 S X ST W) T 
%     (sub-tp/tbind1 (tf/c S) XAB STAB' W2)
%     (sub-tp/tbind1 (tf/c S) XA STA' W2)
%     (sub-tp/tbind1 S X STB W)
% 
%       <- extend-wf-tp W T W2
%       <- extend-sub-tp ST T STAB STA STB
%       <- extend-swap-sub-tp1 STAB X S STAB' XAB 
%       <- extend-swap-sub-tp1 STA X S STA' XA.
% 
% 
% - : extend-sub-tp (sub-tp/tbind2 S X ST W) T 
%     (sub-tp/tbind2 (tf/c S) XAB STAB' W2)
%     (sub-tp/tbind2 S X STA W)
%     (sub-tp/tbind2 (tf/c S) XB STB' W2)
%       <- extend-wf-tp W _ W2
%       <- extend-sub-tp ST _ STAB STA STB
%       <- extend-swap-sub-tp2 STAB X S STAB' XAB 
%       <- extend-swap-sub-tp2 STB X S STB' XB.

- : extend-sub-tp (sub-tp/tbindh SE S ST1 ST2 W) T
     (sub-tp/tbindh (sub-env/ext SE) S STB1 STB2 W)
     (sub-tp/tbindh SE S STB1 STB2 W)
     (sub-tp/tbindh (sub-env/ext SE) S ST1 ST2 W)
     <- extend-sub-tp ST1 T STA1 STB1 STC1
     <- extend-sub-tp ST2 T STA2 STB2 STC2
     .

%worlds () (extend-wf-tp _ _ _)(extend-sub-tp _ _ _ _ _)(extend-wf-pev _ _ _).
%total (A B C) (extend-wf-tp A _ _)(extend-sub-tp B _ _ _ _)(extend-wf-pev C _ _).

extend-sub-tp12: sub-tp G1 T1 G2 T2 -> {Z: tpe} sub-tp (tcons Z G1) T1 (tcons Z G2) T2 -> type.
%mode extend-sub-tp12 +A +B -C.
- : extend-sub-tp12 ST Z ST' <- extend-sub-tp ST Z ST' _ _.
%worlds () (extend-sub-tp12 _ _ _).
%total A (extend-sub-tp12 A _ _).

extend-sub-tp1: sub-tp G1 T1 G2 T2 -> {Z: tpe} sub-tp (tcons Z G1) T1 G2 T2 -> type.
%mode extend-sub-tp1 +A +B -C.
- : extend-sub-tp1 ST Z ST' <- extend-sub-tp ST Z _ ST' _.
%worlds () (extend-sub-tp1 _ _ _).
%total A (extend-sub-tp1 A _ _).

extend-sub-tp2: sub-tp G1 T1 G2 T2 -> {Z: tpe} sub-tp G1 T1 (tcons Z G2) T2 -> type.
%mode extend-sub-tp2 +A +B -C.
- : extend-sub-tp2 ST Z ST' <- extend-sub-tp ST Z _ _ ST'.
%worlds () (extend-sub-tp2 _ _ _).
%total A (extend-sub-tp2 A _ _).











extend-subeq-tp1: subeq-tp G1 T1 G2 T2 -> {Z: tpe} subeq-tp (tcons Z G1) T1 G2 T2 -> type.
%mode extend-subeq-tp1 +A +B -C.
% - : extend-subeq-tp1 (subeq-tp/eq SX2 SX1 W) Z (subeq-tp/eq SX2 (sub-env/ext SX1) W).
- : extend-subeq-tp1 (subeq-tp/sub S) Z (subeq-tp/sub S') <- extend-sub-tp1 S _ S'.
%worlds () (extend-subeq-tp1 _ _ _).
%total A (extend-subeq-tp1 A _ _).

extend-subeq-tp2: subeq-tp G1 T1 G2 T2 -> {Z: tpe} subeq-tp G1 T1 (tcons Z G2) T2 -> type.
%mode extend-subeq-tp2 +A +B -C.
% - : extend-subeq-tp2 (subeq-tp/eq SX2 SX1 W) Z (subeq-tp/eq (sub-env/ext SX2) SX1 W).
- : extend-subeq-tp2 (subeq-tp/sub S) Z (subeq-tp/sub S') <- extend-sub-tp2 S _ S'.
%worlds () (extend-subeq-tp2 _ _ _).
%total A (extend-subeq-tp2 A _ _).






extend-wf-tp-mult: wf-tp G1 T1 -> sub-env G1 G2 -> wf-tp G2 T1 -> type.
%mode extend-wf-tp-mult +A +B -C.
- : extend-wf-tp-mult W sub-env/refl W.
- : extend-wf-tp-mult W (sub-env/ext S) W2
    <- extend-wf-tp-mult W S W1
    <- extend-wf-tp W1 _ W2.
%worlds () (extend-wf-tp-mult _ _ _).
%total A (extend-wf-tp-mult _ A _).


extend-sub-tp1-mult: sub-tp G1 T1 G2 T2 -> sub-env G1 G3 -> sub-tp G3 T1 G2 T2 -> type.
%mode extend-sub-tp1-mult +A +B -C.
- : extend-sub-tp1-mult ST sub-env/refl ST.
- : extend-sub-tp1-mult ST (sub-env/ext S) ST2
    <- extend-sub-tp1-mult ST S ST1
    <- extend-sub-tp1 ST1 _ ST2.
%worlds () (extend-sub-tp1-mult _ _ _).
%total A (extend-sub-tp1-mult _ A _).

extend-sub-tp2-mult: sub-tp G1 T1 G2 T2 -> sub-env G2 G3 -> sub-tp G1 T1 G3 T2 -> type.
%mode extend-sub-tp2-mult +A +B -C.
- : extend-sub-tp2-mult ST sub-env/refl ST.
- : extend-sub-tp2-mult ST (sub-env/ext S) ST2
    <- extend-sub-tp2-mult ST S ST1
    <- extend-sub-tp2 ST1 _ ST2.
%worlds () (extend-sub-tp2-mult _ _ _).
%total A (extend-sub-tp2-mult _ A _).




extend-wf-pev-mult : path-eval G E T -> sub-env G G1 -> path-eval G1 E T -> type.
%mode extend-wf-pev-mult +A +B -C.

- : extend-wf-pev-mult (pev L W) S (pev L1 W1)
      <- extend-wf-tp-mult W S W1
      <- extend-wf-lkp-mult L S L1.

%worlds () (extend-wf-pev-mult _ _ _).
%total (A) (extend-wf-pev-mult A _ _).





% Extract wf from subtyping

extract-wf : sub-tp G1 T1 G2 T2 -> wf-tp G1 T1 -> wf-tp G2 T2 -> type.
%mode extract-wf +SBT1 -SBT2 -SBT3.

extract-wf-pev : path-eval G E T -> wf-tp G T -> type.
%mode extract-wf-pev +P -S.

- : extract-wf-pev (pev L W) W.


- : extract-wf sub-tp/int wf-tp/int wf-tp/int.
- : extract-wf sub-tp/bool wf-tp/bool wf-tp/bool.
- : extract-wf (sub-tp/top W) W wf-tp/top.
- : extract-wf (sub-tp/bot W) wf-tp/bot W.
- : extract-wf (sub-tp/fun (ST1:sub-tp G1 T2 G2 T4) (ST2:sub-tp G2 T3 G1 T1)) 
        (wf-tp/fun W2 W1) (wf-tp/fun W4 W3)
      <- extract-wf ST1 W2 W4
      <- extract-wf ST2 W3 W1.
- : extract-wf (sub-tp/rect ST1 ST2 B2 B1) (wf-tp/rect B1 W2 W1) (wf-tp/rect B2 W4 W3) %% FIXME: T1<:T2 & T3 <: T4
      <- extract-wf ST1 W2 W4
      <- extract-wf ST2 W3 W1.
- : extract-wf (sub-tp/recv ST) (wf-tp/recv W1) (wf-tp/recv W2)
      <- extract-wf ST W1 W2.

- : extract-wf (sub-tp/tsel1 ST P) 
      (wf-tp/tsel P) W2
      <- extract-wf ST _ W2. % W1 W2

- : extract-wf (sub-tp/tsel2 ST P) 
      W1 (wf-tp/tsel P)
      <- extract-wf ST W1 _. % W1 W2

- : extract-wf (sub-tp/tselx ST ST2 P S1 S2)
      (wf-tp/tsel P1)
      (wf-tp/tsel P2)
      <- extend-wf-pev-mult P S1 P1
      <- extend-wf-pev-mult P S2 P2.

% - : extract-wf (sub-tp/tbind1 S X ST W) W W2
%       <- extract-wf ST _ W2.
% 
% - : extract-wf (sub-tp/tbind2 S X ST W) W1 W
%       <- extract-wf ST W1 _.

- : extract-wf (sub-tp/tbindh ES S SW SE W) W1 W'
      <- extract-wf SE W1 _
      <- extend-wf-tp-mult W ES W'.


%worlds () (extract-wf _ _ _)(extract-wf-pev _ _).
%total (A B) (extract-wf A _ _)(extract-wf-pev B _).





%% Diamond property w.r.t. environment for well formed types

wf-tp-min: 
  wf-tp G1 T -> wf-tp G2 T -> minmax-env G1 G2 GS GU ->
  wf-tp GS T -> sub-env GS G1 -> sub-env GS G2 ->
  type.
%mode wf-tp-min +A +B +C -F -G -H.

- : wf-tp-min W1 W2 (mm-env/1 S12) W1 sub-env/refl S12.
- : wf-tp-min W1 W2 (mm-env/2 S21) W2 S21 sub-env/refl.

%worlds () (wf-tp-min _ _ _ _ _ _).
%total A (wf-tp-min A _ _ _ _ _ ).


wf-tp-dia: 
  wf-tp GT T -> wf-tp G1 T -> wf-tp G2 T -> sub-env G1 GT -> sub-env G2 GT ->
  wf-tp G T -> sub-env G G1 -> sub-env G G2 ->
  type.
%mode wf-tp-dia +A +B +C +D +E -F -G -H.

- : wf-tp-dia WT W1 W2 S1 S2 W0 S01 S02
     <- sub-env-dia S1 S2 MM
     <- wf-tp-min W1 W2 MM W0 S01 S02.


%worlds () (wf-tp-dia _ _ _ _ _ _ _ _).
%total A (wf-tp-dia A _ _ _ _ _ _ _).


pev-tp-min: 
  path-eval G1 N T -> path-eval G2 N T -> minmax-env G1 G2 GS GU ->
  path-eval GS N T -> sub-env GS G1 -> sub-env GS G2 ->
  type.
%mode pev-tp-min +A +B +C -F -G -H.

- : pev-tp-min W1 W2 (mm-env/1 S12) W1 sub-env/refl S12.
- : pev-tp-min W1 W2 (mm-env/2 S21) W2 S21 sub-env/refl.

%worlds () (pev-tp-min _ _ _ _ _ _).
%total A (pev-tp-min A _ _ _ _ _ ).


pev-tp-dia: 
  path-eval GT N T -> path-eval G1 N T -> path-eval G2 N T -> sub-env G1 GT -> sub-env G2 GT ->
  path-eval G N T -> sub-env G G1 -> sub-env G G2 ->
  type.
%mode pev-tp-dia +A +B +C +D +E -F -G -H.

- : pev-tp-dia WT W1 W2 S1 S2 W0 S01 S02
     <- sub-env-dia S1 S2 MM
     <- pev-tp-min W1 W2 MM W0 S01 S02.


%worlds () (pev-tp-dia _ _ _ _ _ _ _ _).
%total A (pev-tp-dia A _ _ _ _ _ _ _).








% Restrict subeq - placed here because it uses wf-tp-dia (does it have to?)

restrict-sub-tp: sub-tp G1 T1 G2 T2 
  -> wf-tp G1 T1
  -> wf-tp G2 T2
  -> {Z: tpe} sub-tp (tcons Z G1) T1 (tcons Z G2) T2 
  -> type.
%mode restrict-sub-tp -A +B +C +D +E.

- : restrict-sub-tp sub-tp/int W1 W2 T sub-tp/int.
- : restrict-sub-tp sub-tp/bool W1 W2 T  sub-tp/bool.
- : restrict-sub-tp (sub-tp/top W1) W1 W2 T (sub-tp/top _). 
- : restrict-sub-tp (sub-tp/bot W2) W1 W2 T (sub-tp/bot _). 
- : restrict-sub-tp (sub-tp/fun ST1 ST2) (wf-tp/fun W1 W2) (wf-tp/fun W3 W4) T (sub-tp/fun ST1' ST2')
      <- restrict-sub-tp ST1 W1 W3 T ST1'
      <- restrict-sub-tp ST2 W4 W2 T ST2'.
- : restrict-sub-tp (sub-tp/rect ST1 ST2 B2 B1) (wf-tp/rect SB1 W1 W2) (wf-tp/rect SB2 W3 W4) T (sub-tp/rect ST1' ST2' B2' B1')
      <- restrict-sub-tp B2 W4 W3 T B2'
      <- restrict-sub-tp B1 W2 W1 T B1'
      <- restrict-sub-tp ST1 W1 W3 T ST1'
      <- restrict-sub-tp ST2 W4 W2 T ST2'.
- : restrict-sub-tp (sub-tp/recv ST1) (wf-tp/recv W1) (wf-tp/recv W2) T (sub-tp/recv ST1')
      <- restrict-sub-tp ST1 W1 W2 T ST1'.

- : restrict-sub-tp 
    (sub-tp/tsel1 ST (pev L1 (wf-tp/rect SF WU WS)))
    ((wf-tp/tsel     (pev L1 (wf-tp/rect SF WU WS))): (wf-tp _ (tsel (var N))))
    W2 T 
    (sub-tp/tsel1 ST' (pev L' (wf-tp/rect SF' WU' WS')))

      % first extend L1, then prove it's equal to L',
      % establishing that we can use L1 in the result

      <- extend-wf-lkp L1 T L1'  

      <- eq-refl N E
      <- lookup-eq L1' L' E _ SA
      <- lookup-eq L' L1' E _ SB  % need the other direction to convert back

      <- eq-wf SA WU WUQ
      <- restrict-sub-tp STQ WUQ W2 T ST'
      <- eq-low SB STQ ST.

- : restrict-sub-tp 
    (sub-tp/tsel2 ST (pev L1 (wf-tp/rect SF WU WS)))
    W1
    ((wf-tp/tsel     (pev L1 (wf-tp/rect SF WU WS))): (wf-tp _ (tsel (var N))))
    T 
    (sub-tp/tsel2 ST' (pev L' (wf-tp/rect SF' WU' WS')))

      % first extend L1, then prove it's equal to L',
      % establishing that we can use L1 in the result

      <- extend-wf-lkp L1 T L1'  

      <- eq-refl N E
      <- lookup-eq L1' L' E SA _
      <- lookup-eq L' L1' E SB _  % need the other direction to convert back

      <- eq-wf SA WS WSQ
      <- restrict-sub-tp STQ W1 WSQ T ST'
      <- eq-high SB STQ ST.


- : restrict-sub-tp (sub-tp/tselx ST ST2 P S1 S2) W1 W2 T (sub-tp/tselx ST' ST2' P' S1' S2')
      <- extend-wf-tp-mult (wf-tp/tsel P') S1' W1'
      <- extend-wf-tp-mult (wf-tp/tsel P') S2' W2'
      <- wf-tp-dia W1' W1 (wf-tp/tsel P') (sub-env/ext sub-env/refl) S1' (wf-tp/tsel P1) S1A S1B
      <- wf-tp-dia W2' W2 (wf-tp/tsel P') (sub-env/ext sub-env/refl) S2' (wf-tp/tsel P2) S2A S2B
      <- wf-tp-dia (wf-tp/tsel P') (wf-tp/tsel P1) (wf-tp/tsel P2) S1B S2B (wf-tp/tsel P) S3A S3B
      <- sub-env-trans S3A S1A S1
      <- sub-env-trans S3B S2A S2

      <- extract-wf-pev P WX0
      <- extend-wf-tp-mult WX0 S1 WX1
      <- extend-wf-tp-mult WX0 S2 WX2

      <- restrict-sub-tp ST WX1 WX2 _ ST'
      <- restrict-sub-tp ST2 WX2 WX1 _ ST2'
      .



%%% PROBLEM WITH TERMINATION ORDER

restrict-sub-tp1: sub-tp G1 T1 G2 T2 -> wf-tp G1 T1 -> {Z: tpe} sub-tp (tcons Z G1) T1 G2 T2 -> type.
%mode restrict-sub-tp1 -A +Y +B +C.
%worlds () (restrict-sub-tp1 _ _ _ _).
%trustme
%total A (restrict-sub-tp1 _ _ _ A).


magic: 
{WW:wf-tp (tcons (bindh X5) G0) (X5 (var S0))}  
{SW:tsize G0 (var S0)}
{SEW:sub-env G0 G1}

{ST2:sub-tp X1 X2 (tcons X3 G2) (X5 (var S2))}

{SZ1:tsize G2 (var S2)} %% G2 = tcons N T G1 FR
{SX:sub-env G1 G2}

{S:tsize G1 (var S1)}
{ST2x:sub-tp X1 X2 (tcons X3 G1) (X5 (var S1))}
type.

%mode magic +A +B +C +D +E +F +G -H.
%worlds () (magic _ _ _ _ _ _ _ _).
%trustme
%total (A) (magic A _ _ _ _ _ _ _).


- : restrict-sub-tp % easy case: G0 is already smaller than target
     (sub-tp/tbindh SE S ST1 ST2 W)
     W1
     (wf-tp/tbindh SEW SW WW)
     T
     (sub-tp/tbindh (sub-env/ext SE) S STA1 STA2 W)
       <- restrict-sub-tp1 ST1 W1 T STA1
       <- restrict-sub-tp1 ST2 W1 T STA2
       .


- : restrict-sub-tp % hard case: G0 = G2 = (T G2')
     (sub-tp/tbindh sub-env/refl S ST1 ST2x (wf-tp/tbindh SEW SW WW)) 
     W1
     (wf-tp/tbindh SEW SW WW)
     T
     (sub-tp/tbindh sub-env/refl (tf/c S) STA1 STA2 W)
       <- restrict-sub-tp1 ST1 W1 T STA1
       <- restrict-sub-tp1 ST2 W1 T STA2
       <- magic WW SW SEW ST2 (tf/c S) (sub-env/ext sub-env/refl) S ST2x
       .



%worlds () (restrict-sub-tp _ _ _ _ _).
%trustme %%% output not free 
%total (A) (restrict-sub-tp _ _ _ _ A).






restrict-sub-tp1: sub-tp G1 T1 G2 T2 -> wf-tp G1 T1 -> {Z: tpe} sub-tp (tcons Z G1) T1 G2 T2 -> type.
%mode restrict-sub-tp1 -A +Y +B +C.

- : restrict-sub-tp1 ST W1 T ST1 
    <- extend-sub-tp2 ST1 T ST12
    <- extract-wf ST1 _ W2
    <- restrict-sub-tp ST W1 W2 T ST12.

%worlds () (restrict-sub-tp1 _ _ _ _).
%total A (restrict-sub-tp1 _ _ _ A).


restrict-sub-tp2: sub-tp G1 T1 G2 T2 -> wf-tp G2 T2 -> {Z: tpe} sub-tp G1 T1 (tcons Z G2) T2 -> type.
%mode restrict-sub-tp2 -A +Y +B +C.

- : restrict-sub-tp2 ST W2 T ST2 
    <- extend-sub-tp1 ST2 T ST12
    <- extract-wf ST2 W1 _
    <- restrict-sub-tp ST W1 W2 T ST12.

%worlds () (restrict-sub-tp2 _ _ _ _).
%total A (restrict-sub-tp2 _ _ _ A).

restrict-sub-tp1-mult: sub-tp G1 T1 G2 T2 -> wf-tp G0 T1 -> sub-env G0 G1 -> sub-tp G0 T1 G2 T2 -> type.
%mode restrict-sub-tp1-mult +A +B +C -D.
- : restrict-sub-tp1-mult ST W sub-env/refl ST.
- : restrict-sub-tp1-mult ST W (sub-env/ext S) ST2
    <- extend-wf-tp-mult W S WX
    <- restrict-sub-tp1 ST1 WX _ ST
    <- restrict-sub-tp1-mult ST1 W S ST2.
%worlds () (restrict-sub-tp1-mult _ _ _ _).
%total A (restrict-sub-tp1-mult _ _ A _).

restrict-sub-tp2-mult: sub-tp G1 T1 G2 T2 -> wf-tp G0 T2 -> sub-env G0 G2 -> sub-tp G1 T1 G0 T2 -> type.
%mode restrict-sub-tp2-mult +A +B +C -D.
- : restrict-sub-tp2-mult ST W sub-env/refl ST.
- : restrict-sub-tp2-mult ST W (sub-env/ext S) ST2
    <- extend-wf-tp-mult W S WX
    <- restrict-sub-tp2 ST1 WX _ ST
    <- restrict-sub-tp2-mult ST1 W S ST2.
%worlds () (restrict-sub-tp2-mult _ _ _ _).
%total A (restrict-sub-tp2-mult _ _ A _).





restrict-subeq-tp2: subeq-tp G1 T1 G2 T2 -> wf-tp G2 T2 -> {Z: tpe} subeq-tp G1 T1 (tcons Z G2) T2 -> type.
%mode restrict-subeq-tp2 -A +Y +B +C.
% - : restrict-subeq-tp2 (subeq-tp/eq S2' SX1' W') W2 Z (subeq-tp/eq SX2 SX1 W)
%         <- extend-wf-tp W2 Z WT
%         <- wf-tp-dia WT W2 W (sub-env/ext sub-env/refl) SX2 W' S2' S1'
%         <- sub-env-trans S1' SX1 SX1'.
- : restrict-subeq-tp2 (subeq-tp/sub S) W2 Z (subeq-tp/sub S') 
        <- restrict-sub-tp2 S W2 _ S'.
%worlds () (restrict-subeq-tp2 _ _ _ _).
%total A (restrict-subeq-tp2 _ _ _ A).






%% In test8, Subtyping of type selections was not reflexive because of type bounds.
%% Now we have sub-tp/tselx, so reflexivity holds again.
%% None of the proofs depend on it though.

%% Subtyping is reflexive

sub-tp-refl : 
  %% Input
  wf-tp G T ->
  %% Output
  sub-tp G T G T ->
  type.
%mode sub-tp-refl +WT -SBT.

-/int : sub-tp-refl wf-tp/int sub-tp/int.
-/bool: sub-tp-refl wf-tp/bool sub-tp/bool.
-/bot : sub-tp-refl wf-tp/bot (sub-tp/bot wf-tp/bot).
-/top : sub-tp-refl wf-tp/top (sub-tp/top wf-tp/top).
-/fun : sub-tp-refl (wf-tp/fun T1 T2) (sub-tp/fun SBT1 SBT2)
   <- sub-tp-refl T1 SBT1
   <- sub-tp-refl T2 SBT2.
-/rect: sub-tp-refl (wf-tp/rect ST T1 T2) (sub-tp/rect SBT1 SBT2 ST ST)
   <- sub-tp-refl T1 SBT1
   <- sub-tp-refl T2 SBT2.
-/recv: sub-tp-refl (wf-tp/recv T1) (sub-tp/recv SBT1)
   <- sub-tp-refl T1 SBT1.
-/tsel: sub-tp-refl (wf-tp/tsel P) (sub-tp/tselx ST ST P sub-env/refl sub-env/refl)
   <- extract-wf-pev P W
   <- sub-tp-refl W ST.


% -/tbind: sub-tp-refl (wf-tp/tbind S X W) (sub-tp/tbind2 S X (sub-tp/tbind1 S X SBT1 (wf-tp/tbind S X W)) (wf-tp/tbind S X W))
%    <- sub-tp-refl W SBT1.


%worlds () (sub-tp-refl _ _).
%trustme
%total T (sub-tp-refl T _).





subeq-tp-refl : 
  %% Input
  wf-tp G T ->
  %% Output
  subeq-tp G T G T ->
  type.
%mode subeq-tp-refl +WT -SBT.

-/eq  : subeq-tp-refl W (subeq-tp/sub ST) <- sub-tp-refl W ST.

%worlds () (subeq-tp-refl _ _).
%total T (subeq-tp-refl T _).






%% Subtyping is transitive

sub-tp-trans-aux :
  %% Inputs
%  {G2:tenv}
%  {T2:tpe}
  wf-tp G2 T2 ->
  sub-tp G1 T1 G2 T2 ->
  sub-tp G2 T2 G3 T3 ->
  %% Output
  sub-tp G1 T1 G3 T3 ->
  type.
%mode sub-tp-trans-aux +T2 +SBT1 +SBT2 -SBT3.

-/int    : sub-tp-trans-aux wf-tp/int sub-tp/int sub-tp/int sub-tp/int.
-/bool   : sub-tp-trans-aux wf-tp/bool sub-tp/bool sub-tp/bool sub-tp/bool.

-/top    : sub-tp-trans-aux _ S1 (sub-tp/top _) (sub-tp/top W) <- extract-wf S1 W _.
-/bot    : sub-tp-trans-aux _ (sub-tp/bot _) S2 (sub-tp/bot W) <- extract-wf S2 _ W.


-/fun-fun  : sub-tp-trans-aux
      (wf-tp/fun T2 T1)
            (sub-tp/fun SBT2 SBT1)
            (sub-tp/fun SBT4 SBT3)
            (sub-tp/fun SBT6 SBT5)  
      <- sub-tp-trans-aux T1 SBT3 SBT1 SBT5
      <- sub-tp-trans-aux T2 SBT2 SBT4 SBT6.

-/rect-rect  : sub-tp-trans-aux
      (wf-tp/rect SB T2 T1)
            (sub-tp/rect SBT2 SBT1 B2 B1)
            (sub-tp/rect SBT4 SBT3 B4 B3)
            (sub-tp/rect SBT6 SBT5 B4 B1)
      <- sub-tp-trans-aux T1 SBT3 SBT1 SBT5
      <- sub-tp-trans-aux T2 SBT2 SBT4 SBT6.

-/recv-recv  : sub-tp-trans-aux
      (wf-tp/recv T1)
            (sub-tp/recv SBT1)
            (sub-tp/recv SBT3)
            (sub-tp/recv SBT5)  
      <- sub-tp-trans-aux T1 SBT1 SBT3 SBT5.


%% case p.T < p.T && p.T < T3   -->   p.T < T3

-/tselx1  : sub-tp-trans-aux
      (wf-tp/tsel (pev (P0: (tlookup G2 (var N) (rect T2 T2U))) (wf-tp/rect AB (WU: wf-tp G2 T2U) (W: wf-tp G2 T2)) ))

      (sub-tp/tselx (sub-tp/rect (SY24:sub-tp G1 T2UA G2 T2UA) SY31 SY34 SY12) _ (pev (P1: (tlookup G0 (var N) (rect T2A T2UA))) (wf-tp/rect AB1 W1X W1Y)) (SX1: sub-env G0 G1) (SX2: sub-env G0 G2))

      (sub-tp/tsel1 (A2: sub-tp G2 T2UB G3 T3) (pev (P2: (tlookup G2 (var N) (rect T2B T2UB))) (wf-tp/rect AB2 W2X W2Y)))
      (sub-tp/tsel1 SBT5 (pev PXX (wf-tp/rect AB11' W1X1' W1Y1')))


      <- extend-wf-pev-mult (pev P1 (wf-tp/rect AB1 W1X W1Y)) SX1 (pev PXX (wf-tp/rect AB11' W1X1' W1Y1'))
      <- extend-wf-pev-mult (pev P1 (wf-tp/rect AB1 W1X W1Y)) SX2 (pev P1' (wf-tp/rect AB1' W1X' W1Y'))

      <- eq-refl N Q
      <- lookup-eq P0 P1' Q (S3: same T2  T2A) (S4: same T2U  T2UA)
      <- lookup-eq P2 P1' Q (S1: same T2B T2A) (S2: same T2UB T2UA)

      <- eq-low S2 (A2: sub-tp G2 T2UB G3 T3) (A2': sub-tp G2 T2UA G3 T3)
      <- eq-wf S4 (WU: wf-tp G2 T2U) (WU': wf-tp G2 T2UA)

      <- sub-tp-trans-aux WU' SY24 A2' SBT5
      .


%% case T1 < p.T && p.T < p.T   -->   T1 < p.T

-/tselx2  : sub-tp-trans-aux
      (wf-tp/tsel (pev (P0: (tlookup G2 (var N) (rect T2 T2U))) (wf-tp/rect AB (WU: wf-tp G2 T2U) (W: wf-tp G2 T2)) ))

      (sub-tp/tsel2 (A1: sub-tp G1 T1 G2 T2A) (pev (P1: (tlookup G2 (var N) (rect T2A T2UA))) (wf-tp/rect AB1 W1X W1Y)))

      (sub-tp/tselx _ (sub-tp/rect SY24 SY31 SY34 SY12) (pev (P2: (tlookup G0 (var N) (rect T2B T2UB))) (wf-tp/rect AB2 W2X W2Y)) (SX2: sub-env G0 G2) (SX3: sub-env G0 G3))

      (sub-tp/tsel2 SBT5 (pev PXX (wf-tp/rect AB2' W2X' W2Y')))


      <- extend-wf-pev-mult (pev P2 (wf-tp/rect AB2 W2X W2Y)) SX2 (pev P2' (wf-tp/rect AB21' W2X1' W2Y1'))
      <- extend-wf-pev-mult (pev P2 (wf-tp/rect AB2 W2X W2Y)) SX3 (pev PXX (wf-tp/rect AB2' W2X' W2Y'))

      <- eq-refl N Q
      <- lookup-eq P0 P2' Q (S3: same T2  T2B) (S4: same T2U  T2UB)
      <- lookup-eq P1 P2' Q (S1: same T2A T2B) (S2: same T2UA T2UB)

      <- eq-high S1 (A1: sub-tp G1 T1 G2 T2A) (A1': sub-tp G1 T1 G2 T2B)
      <- eq-wf S3 (W: wf-tp G2 T2) (W': wf-tp G2 T2B)

      <- sub-tp-trans-aux W' A1' SY31 (SBT5: sub-tp G1 T1 G3 T2B)
      .


-/tselx-tselx  : sub-tp-trans-aux
      (wf-tp/tsel (pev (P0: (tlookup G2 (var N) (rect _ _))) WR0 ))

      (sub-tp/tselx ST11 ST12 (pev (P1: (tlookup G0 (var N) (rect _ _))) WR1) (SX1: sub-env G0 G1) (SX2: sub-env G0 G2))

      (sub-tp/tselx ST21 ST22 (pev (P2: (tlookup G0' (var N) (rect _ _))) WR2) (SX2': sub-env G0' G2) (SX3: sub-env G0' G3))

      (sub-tp/tselx ST31 ST32 (pev P3 W00) SX1x SX3x)

      <- eq-refl N Q

      <- extend-wf-pev-mult (pev P1 WR1) SX2 (pev P1' WR1')
      <- extend-wf-pev-mult (pev P2 WR2) SX2' (pev P2' WR2')

      <- lookup-eq P2' P1' Q S1 S2
      <- eq-rect S1 S2 SR1 SR1x      

      <- eq-low SR1 ST21 ST21'
      <- eq-low SR1x ST11 ST11'

      <- eq-high SR1 ST22 ST22'
      <- eq-high SR1x ST12 ST12'

      <- lookup-eq P0 P1' Q S3 S4
      <- eq-rect S3 S4 SR3 SR3x
      <- eq-pev SR3 (pev P0 WR0) (pev P0' WR0')

      <- sub-tp-trans-aux WR0' ST11' ST21' ST31x
      <- sub-tp-trans-aux WR0' ST22' ST12' ST32x

      <- eq-low SR1 ST31x ST31xx %% TODO: reverse order somewhere above??
      <- eq-high SR1 ST31xx ST31

      <- eq-low SR1 ST32x ST32xx
      <- eq-high SR1 ST32xx ST32


      <- eq-pev SR1 (pev P2 WR2) (pev P2S WR2S)

      <- pev-tp-dia (pev P0' WR0') (pev P1 WR1) (pev P2S WR2S) SX2 SX2' (pev P3 W00) S01 S02

      <- sub-env-trans S01 SX1 SX1x
      <- sub-env-trans S02 SX3 SX3x
      .


-/tsel1  : sub-tp-trans-aux  % p.T1 < T2 <-- p:{T1} && T1 < T2
      W
      (sub-tp/tsel1 SBT1 P)
      SBT3
      (sub-tp/tsel1 SBT5 P)
      <- sub-tp-trans-aux W SBT1 SBT3 SBT5.

-/tsel2  : sub-tp-trans-aux  % T1 < p.T2 <-- p:{T1} && T1 < T2
      W
      SBT1
      (sub-tp/tsel2 SBT3 P)
      (sub-tp/tsel2 SBT5 P)
      <- sub-tp-trans-aux W SBT1 SBT3 SBT5.


%% case T1 < p.T2 && p.T2 < T3   -->   T1 < T3


-/tsel2-tsel1  : sub-tp-trans-aux  % T1 < p.T2 && p.T2 < T3 --> T1 < T3
      (wf-tp/tsel (pev (P0: (tlookup G2 (var N) (rect T2 T2U))) (wf-tp/rect AB (WU: wf-tp G2 T2U) (W: wf-tp G2 T2)) ))
      (sub-tp/tsel2 (A1: sub-tp G1 T1 G2 T2A) (pev (P1: (tlookup G2 (var N) (rect T2A T2UA))) (wf-tp/rect _ W1X W1Y)))
      (sub-tp/tsel1 (A2: sub-tp G2 T2UB G3 T3) (pev (P2: (tlookup G2 (var N) (rect T2B T2UB))) (wf-tp/rect _ W2X W2Y)))
      (SBT5: sub-tp G1 T1 G3 T3)
      
      <- eq-refl N Q
      <- lookup-eq P1 P0 Q (S1: same T2A T2) (S3: same T2UA T2U)
      <- lookup-eq P2 P0 Q (S2: same T2B T2) (S4: same T2UB T2U)

      <- eq-high S1 A1 (A1': sub-tp G1 T1 G2 T2)
      <- eq-low  S4 A2 (A2': sub-tp G2 T2U G3 T3)

      <- sub-tp-trans-aux W A1' AB SBT3
      <- sub-tp-trans-aux WU SBT3 A2' SBT5.



% -/tbind1  : sub-tp-trans-aux
%       W
%       (sub-tp/tbind1 S X SBT1 W1)
%       SBT3
%       (sub-tp/tbind1 S X SBT5 W1)
%       <- sub-tp-trans-aux W SBT1 SBT3 SBT5.
% 

% -/tbind2  : sub-tp-trans-aux
%       W
%       SBT1
%       (sub-tp/tbind2 S X SBT3 W1)
%       (sub-tp/tbind2 S X SBT5 W1)
%       <- sub-tp-trans-aux W SBT1 SBT3 SBT5XX.

%{
in the previous formulation of tbind1/tbind2 this was 
a problem. 

we have:

G1 T1 <: G2 T2
G2 T2 <: G3 {z=>T3}    <---    G2 T2 <: (G3,z:T2) T3

and we need to show:

G1 T2 <: G3 {z=>T3}    <---    G1 T1 <: (G3,z:T1) T3


but induction only gives us:   G1 T1 <: (G3,z:T2) T3
}%


-/tbindh  : sub-tp-trans-aux
       W
       SBT1
       (sub-tp/tbindh SE0 S SW SBT3 (wf-tp/tbindh SE1 S1 WY))
       (sub-tp/tbindh SE0 S SW' SBT5 (wf-tp/tbindh SE1 S1 WY))

       <- sub-tp-trans-aux W SBT1 SW SW'
       <- sub-tp-trans-aux W SBT1 SBT3 SBT5.

%worlds () (sub-tp-trans-aux _ _ _ _).
%total {T2 S1 S2} (sub-tp-trans-aux T2 S1 S2 _).




%% Corrollary to sub-tp-trans-aux that doesn't require us to provide
%% WF as an additional argument.

sub-tp-trans :
  %% Inputs
  sub-tp G1 T1 G2 T2 ->
  sub-tp G2 T2 G3 T3 ->
  %% Output
  sub-tp G1 T1 G3 T3 ->
  type.
%mode sub-tp-trans +SBT1 +SBT2 -SBT3.

-/i : sub-tp-trans SBT1 SBT2 SBT3
       <- extract-wf SBT1 T1 T2
       <- sub-tp-trans-aux T2 SBT1 SBT2 SBT3.

%worlds () (sub-tp-trans _ _ _).
%total {A} (sub-tp-trans A _ _).



subeq-tp-trans :
  %% Inputs
  subeq-tp G1 T1 G2 T2 ->
  subeq-tp G2 T2 G3 T3 ->
  %% Output
  subeq-tp G1 T1 G3 T3 ->
  type.
%mode subeq-tp-trans +SBT1 +SBT2 -SBT3.

% - : subeq-tp-trans (subeq-tp/eq SX2 SX1 W1) (subeq-tp/eq SY2 SY1 W2) (subeq-tp/eq SZY2 SZX1 W0)
%       <- extend-wf-tp-mult W1 SX2 WT
%       <- wf-tp-dia WT W1 W2 SX2 SY1 W0 SZ1 SZ2
%       <- sub-env-trans SZ2 SY2 SZY2
%       <- sub-env-trans SZ1 SX1 SZX1.

% - : subeq-tp-trans (subeq-tp/eq SX2 SX1 W1) (subeq-tp/sub S2) (subeq-tp/sub S4)
%       <- restrict-sub-tp1-mult S2 W1 SX2 S3
%       <- extend-sub-tp1-mult S3 SX1 S4.
% - : subeq-tp-trans (subeq-tp/sub S1) (subeq-tp/eq SX2 SX1 W2) (subeq-tp/sub S4)
%       <- restrict-sub-tp2-mult S1 W2 SX1 S3
%       <- extend-sub-tp2-mult S3 SX2 S4.
- : subeq-tp-trans (subeq-tp/sub S1) (subeq-tp/sub S2) (subeq-tp/sub S3) 
      <- sub-tp-trans S1 S2 S3.

%worlds () (subeq-tp-trans _ _ _).
%total {A} (subeq-tp-trans A _ _).





%{ ------- eval-exp / type-exp ----- }%

eval-exp   : venv -> exp -> val -> type.
% e/cst      : eval-exp G (cste C) (cstv C).
% e/prim     : eval-exp G (prm OP E1 E2) V3
%             <- eval-exp G E1 V1 
%             <- eval-exp G E2 V2
%             <- eval-op OP V1 V2 V3.

e/var      : eval-exp G X V <- vlookup G X V.
e/fun      : eval-exp G (fun R R2 T1 T2) (clos R V2 G)
            <- eval-exp G R2 V2.


e/app      : eval-exp G (app E1 E2) V3
            <- eval-exp G E1 (clos R R2 G1)
            <- eval-exp G E2 V2
            <- eval-exp (vcons V2 G1) R V3.

e/sel      : eval-exp G (sel E1) V
            <- eval-exp G E1 (clos R V G1).




type-exp   : tenv -> exp -> tpe -> type.
% t/cst       : type-exp G (cste C) T <- typeof C T.
% t/prim      : type-exp G (prm OP E1 E2) T3
%             <- type-exp G E1 T1 
%             <- type-exp G E2 T1
%             <- type-op OP T1 T2 T3.

t/var      : type-exp G X T <- tlookup G X T <- wf-tp G T.

t/varx     : type-exp G X (rect (tsel X) (tsel X)) 
                <- tlookup G X (rect T1 T2) <- wf-tp G (rect T1 T2).


% whacky way of assigning an intersection type...
t/fun      : type-exp G (fun R R2 TX1 TX2) (arrow T3 T4) 
                <- type-exp (tcons T3 G) R T4
                <- type-exp G R2 T2
                <- wf-tp G (rect TX1 TX2)
                <- wf-tp G (arrow T3 T4).
t/recv     : type-exp G (fun R R2 TX1 TX2) (recv T2)
                <- type-exp (tcons T3 G) R T4
                <- type-exp G R2 T2
                <- wf-tp G (rect TX1 TX2)
                <- wf-tp G (arrow T3 T4).
t/rect     : type-exp G (fun R R2 TX1 TX2) (rect TX1 TX2) 
                <- type-exp (tcons T3 G) R T4
                <- type-exp G R2 T2
                <- wf-tp G (rect TX1 TX2)
                <- wf-tp G (arrow T3 T4).


t/app       : type-exp G (app E1 E2) T2
            <- type-exp G E1 (arrow T1 T2) 
            <- type-exp G E2 T1.

t/sel       : type-exp G (sel E1) T1
            <- type-exp G E1 (recv T1). 

t/sub       : type-exp G E T2
            <- type-exp G E T1
            <- sub-tp G T1 G T2.

%{ ------- well-formedness / typing for values and environment ----- }%

wf-val   : val -> tenv -> tpe -> type.
wf-env   : venv -> tenv -> type.

% wfv/c    : wf-val (cstv C) T <- typeof C T.
wfv/f    : wf-val (clos R R2 H) G (arrow T1 T2)
            <- wf-env H GC
            <- type-exp (tcons T1 GC) R T2
            <- wf-tp G (arrow T1 T2)
            <- subeq-tp GC (arrow T1 T2) G (arrow T1 T2).

wfv/r    : wf-val (clos R R2 H) G (recv T)
            <- wf-val R2 G T.

wfv/t    : wf-val (clos R R2 H) G (rect T1 T2)
            <- wf-tp G (rect T1 T2).
            % <- wf-val R2 G T.


wfv/sub  : wf-val V G T
            <- wf-val V G1 T1
            <- sub-tp G1 T1 G T.


wfe/n    : wf-env vnil tnil. 
wfe/c    : wf-env (vcons V H) (tcons T G) <- wf-val V G T <- wf-env H G.



%{ ------- type well-formedness extractors ----- }%

extract-wf2: type-exp G E1 T1 -> wf-tp G T1 -> type.
%mode extract-wf2 +WFE1 -WFE2.

- : extract-wf2 (t/var W L) W.
- : extract-wf2 (t/varx W L) (wf-tp/rect (sub-tp/tselx ST ST (pev L W) sub-env/refl sub-env/refl) (wf-tp/tsel (pev L W)) (wf-tp/tsel (pev L W))) <- sub-tp-refl W ST.
- : extract-wf2 (t/fun W _ _ TS) W. % <- extract-wf2 TS W <- extract-wf-arrow W W2.  
- : extract-wf2 (t/rect _ W _ _) W.
- : extract-wf2 (t/recv _ _ TS _) (wf-tp/recv W) <- extract-wf2 TS W.
- : extract-wf2 (t/app TS1 (TS2: type-exp _ _ (arrow _ _))) W2 <- extract-wf2 TS2 (wf-tp/fun W2 W1).
- : extract-wf2 (t/sel TS) W <- extract-wf2 TS (wf-tp/recv W).
- : extract-wf2 (t/sub S TS) W2 <- extract-wf S W1 W2.

%worlds () (extract-wf2 _ _).
%total WFE (extract-wf2 WFE _).


extract-wf3: wf-val V G T1 -> wf-tp G T1 -> type.
%mode extract-wf3 +WFE1 -WFE2.

- : extract-wf3 (wfv/r TS) (wf-tp/recv W) <- extract-wf3 TS W.
- : extract-wf3 (wfv/t W) W.
- : extract-wf3 (wfv/f ST WF TS WE) WF. % <- extend-wf-tp WF _ WF'.
- : extract-wf3 (wfv/sub S TS) W2 <- extract-wf S W1 W2.

%worlds () (extract-wf3 _ _).
%total WFE (extract-wf3 WFE _).



%{ ------- wfv: extending and restricting the environment / type ----- }%


restrict-wfv: wf-val X3 X2 X1 -> wf-tp X2 X1 -> {Z: tpe} wf-val X3 (tcons Z X2) X1 -> type.
%mode restrict-wfv -A +X +B +C.

-     : restrict-wfv (wfv/sub ST WV) WT T (wfv/sub ST1 WV) 
            <- restrict-sub-tp2 ST WT T ST1.
-     : restrict-wfv (wfv/f ST WF TE WE) WF T (wfv/f ST1 WF1 TE WE)
            <- restrict-subeq-tp2 ST WF T ST1.
-     : restrict-wfv (wfv/r WV) (wf-tp/recv WT) T (wfv/r WV1)
            <- restrict-wfv WV WT T WV1.
-     : restrict-wfv (wfv/t WT) WT T (wfv/t W1).

%worlds () (restrict-wfv _ _ _ _).
%total A (restrict-wfv _ _ _ A).


extend-wfv: wf-val X3 X2 X1 -> {Z: tpe} wf-val X3 (tcons Z X2) X1 -> type.
%mode extend-wfv +A +B -C.

-     : extend-wfv (wfv/sub ST WV) T (wfv/sub ST1 WV) 
            <- extend-sub-tp2 ST T ST1.
-     : extend-wfv (wfv/f ST WF TE WE) T (wfv/f ST1 WF1 TE WE)
            <- extend-wf-tp WF T WF1
            <- extend-subeq-tp2 ST T ST1.
-     : extend-wfv (wfv/r WV) T (wfv/r WV1)
            <- extend-wfv WV T WV1.
-     : extend-wfv (wfv/t W) T (wfv/t W1)
            <- extend-wf-tp W T W1.

%worlds () (extend-wfv _ _ _).
%total A (extend-wfv A _ _).


wfv-narrow-env: wf-tp G0 T1 -> sub-env G0 G1 -> wf-val V G1 T1 -> wf-val V G0 T1 -> type.
%mode wfv-narrow-env +A +B +C -D.

- : wfv-narrow-env W sub-env/refl WV WV.
- : wfv-narrow-env (W: wf-tp G0 T1) (sub-env/ext (S: sub-env G0 G1)) 
                        (WV: wf-val V (tcons Z G1) T1) (WV2: wf-val V G0 T1)
      <- extend-wf-tp-mult W S W1
      <- restrict-wfv (WV1: wf-val V G1 T1) W1 _ WV
      <- wfv-narrow-env W S WV1 WV2.

%worlds () (wfv-narrow-env _ _ _ _).
%total A (wfv-narrow-env _ A _ _).


wfv-widen-env: sub-env G1 G2 -> wf-val V G1 T1 -> wf-val V G2 T1 -> type.
%mode wfv-widen-env +LTE1 +LTE2 -LTE3.

- : wfv-widen-env sub-env/refl WV WV.
- : wfv-widen-env (sub-env/ext S) WV WVX
      <- wfv-widen-env S WV WV1
      <- extend-wfv WV1 Z WVX.

%worlds () (wfv-widen-env _ _ _).
%total A (wfv-widen-env A _ _).


wfv-widen: subeq-tp G1 T1 G2 T2 -> wf-val V G1 T1 -> wf-val V G2 T2 -> type.
%mode wfv-widen +LTE1 +LTE2 -LTE3.

% - : wfv-widen (subeq-tp/eq SX2 SX1 W) WV1 WV2 
%      <- wfv-narrow-env W SX1 WV1 WV0 
%      <- wfv-widen-env SX2 WV0 WV2.
- : wfv-widen (subeq-tp/sub S) W (wfv/sub S W).

%worlds () (wfv-widen _ _ _).
%total A (wfv-widen A _ _).



%{ ------- suptyping inversion: type-exp ----- }%


% no intersection/union types yet, encode

subeq-tp-cases: tenv -> tpe -> tenv -> tpe  ->  
        tenv -> tpe -> tenv -> tpe  ->  
        tenv -> tpe -> tenv -> tpe  ->  type.
case-f : subeq-tp G1 T1 G2 T2 -> subeq-tp-cases G1 T1 G2 T2 _ _ _ _ _ _ _ _.
case-r : subeq-tp G1 T1 G2 T2 -> subeq-tp-cases _ _ _ _ G1 T1 G2 T2 _ _ _ _.
case-t : subeq-tp G1 T1 G2 T2 -> subeq-tp-cases _ _ _ _ _ _ _ _ G1 T1 G2 T2.

cases-wfv: subeq-tp-cases 
    G1A T0 G2 T 
    G1B T1 G2 T
    G1C T2 G2 T
    -> wf-val V G1A T0 
    -> wf-val V G1B T1
    -> wf-val V G1C T2
    -> wf-val V G2 T
    -> type.
%mode cases-wfv +C +W1 +W2 +W3 -W.

- : cases-wfv (case-f ST) WF WR WT WF1 <- wfv-widen ST WF WF1.
- : cases-wfv (case-r ST) WF WR WT WR1 <- wfv-widen ST WR WR1.
- : cases-wfv (case-t ST) WF WR WT WT1 <- wfv-widen ST WT WT1.

%worlds () (cases-wfv _ _ _ _ _).
%total WFE (cases-wfv WFE _ _ _ _). 


extract-wf4: subeq-tp G1 T1 G2 T2 -> wf-tp G1 T1 -> wf-tp G2 T2 -> type.
%mode extract-wf4 +A -B -C.
% - : extract-wf4 (subeq-tp/eq S2 S1 W) W1 W2 <- extend-wf-tp-mult W S1 W1  <- extend-wf-tp-mult W S2 W2.
- : extract-wf4 (subeq-tp/sub ST) W1 W2 <- extract-wf ST W1 W2.
%worlds () (extract-wf4 _ _ _).
%total WFE (extract-wf4 WFE _ _). 



%% this will need to change if we add non-closure values

assign-rect: wf-val V G0 T -> wf-tp G (rect T1 T2) -> wf-val V G (rect T1 T2) -> type.
%mode assign-rect +A +B -C.
- : assign-rect (wfv/f _ _ _ _) W (wfv/t W).
- : assign-rect (wfv/r _) W (wfv/t W).
- : assign-rect (wfv/t _) W (wfv/t W).
- : assign-rect (wfv/sub S T) W T' <- assign-rect T W T'.
%worlds () (assign-rect _ _ _).
%total WFE (assign-rect WFE _ _). 


cases-wfv-rect: subeq-tp-cases 
    G1A T0 G2 T 
    G1B T1 G2 T
    G1C (rect T2S T2U) G2 T
    -> wf-val V G1A T0 
    -> wf-val V G1B T1
    -> wf-val V G1C TX
    -> wf-val V G2 T
    -> type.
%mode cases-wfv-rect +C +W1 +W2 +W3 -W.

- : cases-wfv-rect (case-f ST) WF WR WT WF1 <- wfv-widen ST WF WF1.
- : cases-wfv-rect (case-r ST) WF WR WT WR1 <- wfv-widen ST WR WR1.
- : cases-wfv-rect (case-t ST) WF WR WT WT1 
      <- extract-wf4 ST W1 W2 
      <- assign-rect WT W1 WT0
      <- wfv-widen ST WT0 WT1.

%worlds () (cases-wfv-rect _ _ _ _ _).
%total WFE (cases-wfv-rect WFE _ _ _ _). 



%{
TODO generalize: why doesn't this work??

cases-map: subeq-tp-cases 
    G1A T0 G2 T 
    G1B T1 G2 T
    G1C T2 G2 T
    -> (subeq-tp G1A T0 G2 T -> wf-val V G2 T) 
    -> (subeq-tp G1B T0 G2 T -> wf-val V G2 T)
    -> (subeq-tp G1C T0 G2 T -> wf-val V G2 T)
    -> wf-val V G2 T
    -> type.
%mode cases-map +C +W1 +W2 +W3 -W.

- : cases-map (case-f ST) WF WR WT (WF ST).
- : cases-map (case-r ST) WF WR WT (WR ST).
- : cases-map (case-t ST) WF WR WT (WT ST).

%worlds () (cases-map _ _ _ _ _).
%total WFE (cases-map WFE _ _ _ _). 
}%


cases-subeq-trans: subeq-tp-cases 
    G1A T0 G2 T 
    G1B T1 G2 T
    G1C T2 G2 T
    -> subeq-tp G2 T G3 TU
    -> subeq-tp-cases
    G1A T0 G3 TU 
    G1B T1 G3 TU
    G1C T2 G3 TU
    -> type.
%mode cases-subeq-trans +C +W1 -S.

- : cases-subeq-trans (case-f S1) S2 (case-f S3) <- subeq-tp-trans S1 S2 S3.
- : cases-subeq-trans (case-r S1) S2 (case-r S3) <- subeq-tp-trans S1 S2 S3.
- : cases-subeq-trans (case-t S1) S2 (case-t S3) <- subeq-tp-trans S1 S2 S3.

%worlds () (cases-subeq-trans _ _ _).
%total WFE (cases-subeq-trans WFE _ _). 


% we could even strengthen it slightly: tcons in output not strictly necessary

subeq-tp-recv: subeq-tp G1 T1 G2 T2 -> subeq-tp G1 (recv T1) G2 (recv T2) -> type.
%mode subeq-tp-recv +C -S.

% - : subeq-tp-recv (subeq-tp/eq SX1 SX2 W) (subeq-tp/eq SX1 SX2 (wf-tp/recv W)).
- : subeq-tp-recv (subeq-tp/sub S) (subeq-tp/sub (sub-tp/recv S)).

%worlds () (subeq-tp-recv _ _).
%total WFE (subeq-tp-recv WFE _). 


varx-tp-wf: path-eval G E (rect T1 T2) -> wf-tp G (rect (tsel E) (tsel E)) -> type.
%mode varx-tp-wf +A -B.

- : varx-tp-wf P (wf-tp/rect (sub-tp/tselx ST ST P sub-env/refl sub-env/refl) (wf-tp/tsel P) (wf-tp/tsel P))
    <- extract-wf-pev P W <- sub-tp-refl W ST.

%worlds () (varx-tp-wf _ _).
%total WFE (varx-tp-wf WFE _). 


invert-var :
  %% Input
  type-exp G (var N) T ->
  %% Output
  tlookup G (var N) T1 ->
  wf-tp G T1 ->
  subeq-tp-cases 
    G T1 G T 
    G T1 G T 
    G (rect (tsel (var N)) (tsel (var N))) G T 
  ->
  type.
%mode invert-var +WFE1 -WFE2 -SBT1 -SBT1.

-     : invert-var (t/var W L) L W (case-f SB)
            % <- extract-wf2 (t/var L) W
            <- subeq-tp-refl W SB.
-     : invert-var (t/varx W L) L W (case-t SB) 
            <- varx-tp-wf (pev L W) WS
            <- subeq-tp-refl WS SB.
-     : invert-var (t/sub SB1 TS) L W SB2 
            <- invert-var TS L W SB 
            <- cases-subeq-trans SB (subeq-tp/sub SB1) SB2.

%worlds () (invert-var _ _ _ _).
%total WFE (invert-var WFE _ _ _). 


invert-app : 
  %% Input
  type-exp G (app E1 E2) T ->
  %% Output
  type-exp G E1 (arrow T1 T2) ->
  type-exp G E2 T1 ->
  subeq-tp G T2 G T -> 
  type.
%mode invert-app +WFE1 -WFE2 -WFE3 -SBT.

-     : invert-app (t/app TS1 TS) TS TS1 SB 
            <- extract-wf2 (t/app TS1 TS) W 
            <- subeq-tp-refl W SB.
-     : invert-app (t/sub SB1 TS) L L2 SB2 
            <- invert-app TS L L2 SB 
            <- subeq-tp-trans SB (subeq-tp/sub SB1) SB2.

%worlds () (invert-app _ _ _ _).
%total WFE (invert-app WFE _ _ _).


invert-sel : 
  %% Input
  type-exp G (sel E1) T ->
  %% Output
  type-exp G E1 (recv T1) ->
  subeq-tp G T1 G T -> 
  type.
%mode invert-sel +WFE1 -WFE3 -SBT.

-     : invert-sel (t/sel TS) TS SB 
            <- extract-wf2 (t/sel TS) W 
            <- subeq-tp-refl W SB.
-     : invert-sel (t/sub SB1 TS) L2 SB2 
            <- invert-sel TS L2 SB 
            <- subeq-tp-trans SB (subeq-tp/sub SB1) SB2.

%worlds () (invert-sel _ _ _).
%total WFE (invert-sel WFE _ _).



invert-fun :
  %% Input
  type-exp G (fun R R2 TX1 TX2) T ->
  %% Output
  type-exp (tcons T3 G) R T4 ->
  type-exp G R2 T1 ->
  wf-tp G (arrow T3 T4) ->
  wf-tp G (rect TX1 TX2) ->
  subeq-tp-cases 
    G (arrow T3 T4) G T 
    G (recv T1) G T
    G (rect TX1 TX2) G T
  ->
  type.
%mode invert-fun +WFE1 -WFE2 -WFE3 -WFE4 -WFE5 -SBT1.

-     : invert-fun (t/fun WF WX TSV TS) TS TSV WF WX (case-f SB) 
           <- subeq-tp-refl WF SB.
-     : invert-fun (t/rect WF WX TSV TS) TS TSV WF WX (case-t SB) 
           <- subeq-tp-refl WX SB.
-     : invert-fun (t/recv WF WX TSV TS) TS TSV WF WX (case-r SBR)
           <- extract-wf2 TSV W
           <- subeq-tp-refl W SB
           <- subeq-tp-recv SB SBR.
-     : invert-fun (t/sub SB1 TS) TSV L WF WX SB2 
           <- invert-fun TS TSV L WF WX SB 
           <- cases-subeq-trans SB (subeq-tp/sub SB1) SB2.

%worlds () (invert-fun _ _ _ _ _ _).
%total WFE (invert-fun WFE _ _ _ _ _). 




%{ ------- suptyping inversion: wf-val ----- }%
 
% although we only call this from the outside when we
% know T = T1 -> T2, it seems like internally we need a 
% more general interface (b/c of wfv/sub)

invert-wf-fun-aux :
  %% Input
  wf-val (clos R R2 H) G1 T ->
  subeq-tp G1 T G2 (arrow T1 T2) ->
  %% Output
  type-exp (tcons T3 G) R T4 ->
  wf-env H G ->
  subeq-tp G (arrow T3 T4) G2 (arrow T1 T2) ->
  type.
%mode invert-wf-fun-aux +WFE1 +SBT -WFE2 -WFE3 -SBT1.

-     :  invert-wf-fun-aux ((wfv/f SB1 WF TS WE):(wf-val (clos R R2 H) _ _)) SB0
             TS WE SB
            <- subeq-tp-trans SB1 SB0 SB.


 -     : invert-wf-fun-aux (wfv/sub (SB1: sub-tp G1 TI G T) (TS: wf-val _ G1 TI)) 
                (SB0: subeq-tp G T G2 (arrow T1 T2)) L L1 (SB)
            <- subeq-tp-trans (subeq-tp/sub SB1) SB0 (SB1X: subeq-tp G1 TI G2 (arrow T1 T2))
            <- invert-wf-fun-aux TS SB1X L L1 (SB: subeq-tp _ (arrow T3 T4) G2 (arrow T1 T2)).

%worlds () (invert-wf-fun-aux _ _ _ _ _).
%total WFE (invert-wf-fun-aux WFE _ _ _ _). 


invert-wf-fun :
  %% Input
  wf-val (clos R R2 H) G1 (arrow T1 T2) ->
  %% Output
  type-exp (tcons T3 G) R T4 ->
  wf-env H G ->
  subeq-tp G (arrow T3 T4) G1 (arrow T1 T2) ->
  type.
%mode invert-wf-fun +WFE1 -WFE2 -WFE3 -SBT1.

-     :  invert-wf-fun A B C D 
            <- extract-wf3 A W
            <- subeq-tp-refl W SB
            <- invert-wf-fun-aux A SB B C D.

%worlds () (invert-wf-fun _ _ _ _).
%total WFE (invert-wf-fun WFE _ _ _). 





invert-wf-rec-aux :
  %% Input
  wf-val (clos R R2 H) G1 T ->
  subeq-tp G1 T G2 (recv T2) ->
  %% Output
  wf-val R2 G T4 ->
  subeq-tp G (recv T4) G2 (recv T2) ->
  type.
%mode invert-wf-rec-aux +WFE1 +SBT -WFE3 -SBT1.

-     :  invert-wf-rec-aux ((wfv/r TV):(wf-val (clos R R2 H) _ _)) SB0
            TV SB
           <- extract-wf3 TV W 
           <- subeq-tp-refl (wf-tp/recv W) SB1
           <- subeq-tp-trans SB1 SB0 SB.


 -     : invert-wf-rec-aux (wfv/sub (SB1: sub-tp G1 TI G T) (TS: wf-val _ G1 TI)) 
                (SB0: subeq-tp G T G2 (recv T2)) TV SB
            <- subeq-tp-trans (subeq-tp/sub SB1) SB0 (SB1X: subeq-tp G1 TI G2 (recv T2))
            <- invert-wf-rec-aux TS SB1X TV (SB: subeq-tp _ (recv T4) G2 (recv T2)).


%worlds () (invert-wf-rec-aux _ _ _ _).
%total WFE (invert-wf-rec-aux WFE _ _ _). 


invert-wf-rec :
  %% Input
  wf-val (clos R R2 H) G1 (recv T) ->
  %% Output
  wf-val R2 G T4 ->
  subeq-tp G (recv T4) G1 (recv T) ->
  type.
%mode invert-wf-rec +WFE1 -WFE3 -SBT1.

-     :  invert-wf-rec A B C 
            <- extract-wf3 A W
            <- subeq-tp-refl W SB
            <- invert-wf-rec-aux A SB B C.

%worlds () (invert-wf-rec _ _ _).
%total WFE (invert-wf-rec WFE _ _). 




%{ ------- type preservation ----- }%



% lookup safe

lookup-zero-safe: wf-env H G -> tlookup-zero G (var N2) T -> vlookup-zero H (var N1) V -> eq N1 N2 -> wf-val V G T -> type.
%mode lookup-zero-safe +A +B +C +D -E.

-      : lookup-zero-safe (wfe/c G V) tl/hit vl/hit eq/z V1 
         <- extend-wfv V _ V1.
-      : lookup-zero-safe (wfe/c G V) (tl/miss A) (vl/miss B) (eq/s E) Z1
         <- lookup-zero-safe G A B E Z
         <- extend-wfv Z _ Z1.

%worlds () (lookup-zero-safe _ _ _ _ _).
%total A (lookup-zero-safe A _ _ _ _). % induction on first arg

wf-env-size-eq: wf-env H G -> vsize H (var N1) -> tsize G (var N2) -> eq N1 N2 -> type.
%mode wf-env-size-eq +A +B +C -D.
-      : wf-env-size-eq wfe/n vf/n tf/n eq/z.
-      : wf-env-size-eq (wfe/c G _) (vf/c VS) (tf/c TS) (eq/s E) <- wf-env-size-eq G VS TS E.
%worlds () (wf-env-size-eq _ _ _ _).
%total A (wf-env-size-eq A _ _ _).

lookup-safe: wf-env H G -> tlookup G (var N) T -> vlookup H (var N) V -> wf-val V G T -> type.
%mode lookup-safe +A +B +C -D.

-      : lookup-safe WE (tl TL TA TS) (vl VL VA VS) WV
         <- eq-refl N EN
         <- wf-env-size-eq WE VS TS ES
         <- sub-eq EN ES VA TA EM
         <- lookup-zero-safe WE TL VL EM WV.

%worlds () (lookup-safe _ _ _ _).
%total A (lookup-safe A _ _ _).


subeq-tp-inv-recv: subeq-tp G1 (recv T1) G2 (recv T2) 
  -> subeq-tp G1 T1 G2 T2
  -> type. 
%mode subeq-tp-inv-recv +LTE1 -LTE2.

% - : subeq-tp-inv-recv (subeq-tp/eq SX1 SX2 (wf-tp/recv W)) (subeq-tp/eq SX1 SX2 W).
- : subeq-tp-inv-recv (subeq-tp/sub (sub-tp/recv S)) (subeq-tp/sub S).

%worlds () (subeq-tp-inv-recv _ _).
%total A (subeq-tp-inv-recv A _).

subeq-tp-inv-fun: subeq-tp G1 (arrow T1 T2) G2 (arrow T3 T4) 
  -> subeq-tp G2 T3 G1 T1 
  -> subeq-tp G1 T2 G2 T4
  -> type. 
%mode subeq-tp-inv-fun +LTE1 -LTE2 -LTE3.

% - : subeq-tp-inv-fun (subeq-tp/eq SX1 SX2 (wf-tp/fun W1 W2)) (subeq-tp/eq SX2 SX1 W2) (subeq-tp/eq SX1 SX2 W1).
- : subeq-tp-inv-fun (subeq-tp/sub (sub-tp/fun S1 S2)) (subeq-tp/sub S2) (subeq-tp/sub S1).

%worlds () (subeq-tp-inv-fun _ _ _).
%total A (subeq-tp-inv-fun A _ _).


%{
% eval primitive op safe

eval-op-safe : type-op OP T1 T2 T3 -> eval-op OP V1 V2 V3 -> wf-val V3 T3 -> type.
%mode eval-op-safe +LTE1 +LTE2 -LTE3.

-plus   : eval-op-safe t/plus (ev/v (e/plus _)) (wfv/c -/n).
-eqt    : eval-op-safe t/eq (ev/v (e/eqt _ _)) (wfv/c -/t).
-eqf    : eval-op-safe t/eq (ev/v (e/eqf _)) (wfv/c -/f).

%worlds () (eval-op-safe _ _ _).
%total A (eval-op-safe A _ _). % induction on first arg
}%


eval-safe: type-exp G E T -> wf-env H G -> eval-exp H E V -> wf-val V G T -> type.
%mode eval-safe +A +B +C -D.

% -      : eval-safe (t/cst T) _ (e/cst) (wfv/c T).  
% -      : eval-safe (t/prim T _ _) _ (e/prim V _ _) WF
%           <- eval-op-safe T V WF.

 -      : eval-safe ZT E (e/var L2) V2
          <- invert-var ZT L W CST
          <- lookup-safe E L L2 V
          <- cases-wfv-rect CST V V V V2.

 -      : eval-safe (ZT: type-exp G _ _) E (e/fun EX) W
          <- invert-fun ZT TS TSV WF WX CST
          <- eval-safe TSV E EX WV
          <- subeq-tp-refl WF ST
          <- cases-wfv CST (wfv/f ST WF TS E) (wfv/r WV) (wfv/t WX) W.

-      : eval-safe ZT WE (e/sel EVX) WV3
          <- invert-sel ZT TS ST
          <- eval-safe TS WE EVX WVX
          <- invert-wf-rec WVX WV1 STR
          <- subeq-tp-inv-recv STR ST1
          <- wfv-widen ST1 WV1 WV2
          <- wfv-widen ST WV2 WV3.


-      : eval-safe 
            (ZT: type-exp _ _ T2')
            (WE: wf-env H0 G0)
            (e/app
              (EV3: eval-exp (vcons V2 HC0) R V3) 
              (EVX: eval-exp H0 EXP2 V2) 
              (EVF: eval-exp H0 EXP1 (clos R R2 HC0))
            )
            Z2 % (wfv/sub ST (wfv/sub STR1 (Z: wf-val V3 (tcons T3 GC0) T4)))

          <- invert-app ZT
              (TF: type-exp G0 EXP1 (arrow T1 T2))
              (TX: type-exp G0 EXP2 T1)
              (ST: subeq-tp _ T2 _ T2')

          <- eval-safe          % eval X
              (TX: type-exp _ _ T1)
              WE 
              EVX 
              (WVX: wf-val V2 G0 T1)

          <- eval-safe          % eval F
              TF
              WE 
              (EVF: eval-exp H0 EXP1 (clos R R2 HC0))
              (ZF: wf-val (clos R R2 HC0) G0 (arrow T1 T2))

          <- invert-wf-fun 
              ZF 
              (TR : type-exp (tcons T3 GC0) R T4)
              (WE1: wf-env HC0 GC0)
              STF

          <- subeq-tp-inv-fun 
              (STF: subeq-tp GC0 (arrow T3 T4) G0 (arrow T1 T2))
              (STA: subeq-tp G0 T1 GC0 T3)
              (STR: subeq-tp GC0 T4 G0 T2)

          <- wfv-widen STA WVX WVX3

          <- eval-safe                 % eval F(X)
              (TR: type-exp (tcons T3 GC0) R T4)
              (wfe/c WE1 WVX3)
              (EV3: eval-exp (vcons V2 HC0) R V3) 
              (Z: wf-val V3 (tcons T3 GC0) T4)

          <- extend-subeq-tp1 STR _ (STR1: subeq-tp (tcons T3 GC0) T4 G0 T2)

          <- wfv-widen STR1 (Z: wf-val V3 (tcons T3 GC0) T4) Z1
          <- wfv-widen ST Z1 Z2.



%worlds () (eval-safe _ _ _ _).
%total C (eval-safe A _ C _). % induction on eval-exp

