%%  based on POPLmark submission by Michael Ashley-Rollman, Karl Crary, and Robert Harper.

% + de-hoas
% + add decls / lower bounds
% + index types by depth


%%%%%  Natural numbers  %%%%%

nat : type.  %name nat N.

z : nat.
s : nat -> nat.

nat_eq : nat -> nat -> type.
nat_eq_     : nat_eq N N.


add : nat -> nat -> nat -> type. %name add A.
add/z: add z N N.
add/s: add (s N1) N2 (s N3) <- add N1 N2 N3.



add-reduces: {N1}{N2}{N3}add N1 N2 N3 -> type.
%mode add-reduces +N1 +N2 +N3 +A.
- : add-reduces _ _ _ (add/z).
- : add-reduces _ _ _ (add/s A) <- add-reduces _ _ _ A.
%worlds () (add-reduces _ _ _ _).
%total (A) (add-reduces A _ _ _).
%reduces N2 <= N3 (add-reduces N1 N2 N3 A).




%%%%%  Syntax  %%%%%

tp : type.  %name tp T.

dc: type. %name dc D.

bot     : tp.
top     : tp.
sel     : nat -> tp.
sel2     : nat -> tp.
arrow   : tp -> tp -> tp.
bind    : nat -> dc -> tp -> tp.  %% for all x<:T1 in T2

rect: tp -> tp -> dc.

tenv: type. %name tenv G.
tnil: tenv.
tcons: dc -> tenv -> tenv.



%%%%%  Semantics  %%%%%


mode1: type.
notrans: mode1.
oktrans: mode1.
oktransnosel: mode1.

mode2: type.
nosel: mode2.
oksel: mode2.



stp  : {I1:mode1}{I2:mode2}{I3:mode2} tenv -> tp -> tp -> type.

sdc  : {I1:mode1}{I2:mode2}{I3:mode2} tenv -> dc -> dc -> type.


stp/bot     : stp _ _ _          G bot _.
         
stp/top     : stp _ _ _          G _ top.

stp/sel1    : stp I0 oksel I2            (tcons (rect L U) tnil) (sel z) T
           <- stp oktrans oksel I2       (tcons (rect L U) tnil) U T
           .


stp/sel2    : stp I0 I1 oksel            (tcons (rect L U) tnil) T (sel z)
           <- stp oktrans oksel oksel    (tcons (rect L U) tnil) L U
% need this?           <- stp oktrans I1 oksel       (tcons (rect L U) tnil) T U
           <- stp oktrans I1 oksel       (tcons (rect L U) tnil) T L
           .

stp/arrow   : stp I0 I1 I2         G (arrow S1 S2) (arrow T1 T2)
           <- stp oktrans I2 I1    G T1 S1
           <- stp oktrans I1 I2    G S2 T2
            .


stp/bind    : stp I0 I1 I2         G (bind z S1 S2) (bind z T1 T2)
           <- sdc oktrans oksel oksel      tnil S1 T1 
           <- stp oktrans I1 I2    (tcons S1 tnil) S2 T2
           .

stp/trans   : stp oktrans I1 I3       G T1 T3
           <- stp oktrans I2 I3    G T2 T3
           <- stp oktrans I1 I2    G T1 T2
            .


stp/trans2   : stp oktransnosel I1 I3       G T1 T3
            <- stp oktransnosel nosel I3    G T2 T3
            <- stp oktransnosel I1 nosel    G T1 T2
            .


sdc/rect    : sdc I0 I1 I2       G (rect L1 U1) (rect L2 U2)
           <- stp I0 I2 I2       G L2 U2
           <- stp I0 I1 I1       G L1 U1
           <- stp I0 I1 I2       G U1 U2
           <- stp I0 I2 I1       G L2 L1
            .

% step 1:   T1 < p.L < T2  --->  T1 < L < U < T2



%{

trans: stp notrans I1 nosel G T1 T2 -> stp notrans nosel I3 G T2 T3 -> stp notrans I1 I2 G T1 T3 -> type.
%mode trans +A +B -C.

-/bot:      trans stp/bot _ stp/bot.


%worlds () (trans _ _ _).
%total (A) (trans A _ _).

}%



%{


tX = top.

d1 = (rect top top).
d2 = (rect bot top).
g1 = (tcons d1 tnil).
g2 = (tcons d2 tnil).

1 = (s z).
2 = (s 1).
3 = (s 2).
4 = (s 3).
5 = (s 4).
6 = (s 5).
depth = 6.

m1 = notrans.

%query 1 1 stp m1 _ _ tnil bot top.

%query 1 1 stp m1 _ _ tnil top top.

%query 1 1 stp m1 _ _ tnil (arrow top top) (arrow top top).

%query 1 1 sdc m1 _ _ tnil (rect top top) (rect top top).

%query 1 1 sdc m1 _ _ tnil (rect top top) (rect bot top).


%query 1 1 stp m1 _ _ g1 top top.

%query 1 1 stp m1 _ _ g1 (arrow top top) (arrow top top).

%query 1 1 sdc m1 _ _ g1 (rect top top) (rect top top).

%query 1 1 sdc m1 _ _ g1 (rect top top) (rect bot top).


%query 1 1 stp m1 _ _ g1 top top.

%query 1 1 stp m1 _ _ g1 (arrow top top) (arrow top top).

%query 1 1 sdc m1 _ _ g1 (rect top top) (rect top top).

%query 1 1 sdc m1 _ _ g1 (rect top top) (rect bot top).


%query 1 1 stp m1 _ _ tnil (bind z d1 top) (bind z d1 top).

%query 1 1 stp m1 _ _ tnil (bind z d2 top) (bind z d2 top).

%query 1 1 stp m1 _ _ tnil (bind z d1 top) (bind z d2 top).



%query 1 1 stp m1 I2 I3 (tcons (rect top top) tnil) (sel z) (sel z).

%query 1 1 stp m1 I2 I3 (tcons (rect bot (arrow top top)) tnil) (sel z) (arrow top top).

%query 1 1 stp m1 I2 I3 tnil (bind z (rect bot (arrow top top)) (sel z))
                             (bind z (rect bot (arrow top top)) (arrow bot top)).


%{
  { z => type A: X .. X;   def id(z.A):z.A } <:
  { z => type A: bot..top; def id(z.A):z.A } <:
  { z => type A: bot..top; def id(bot):top } <:
}%

t1 = (bind z (rect (arrow top top) (arrow top top)) (arrow (sel z) (sel z))).
t2 = (bind z (rect bot top) (arrow (sel z) (sel z))).

t3 = (bind z (rect bot top) (arrow bot top)).


%query 1 1 stp m1 _ _ tnil t1 t2.

%query 0 * stp m1 _ _ tnil t2 t1.

%query 1 1 stp m1 _ _ tnil t2 t3.

%query 1 1 stp m1 _ _ tnil t1 t3.


%{
  type Nats = {
    type Nat = { def succ: Nat }
    def zero: Nat
  }
}%


}%





extend-stp: stp I1 I2 I3 tnil T1 T2 -> {T3}stp I1 I2 I3 (tcons T3 tnil) T1 T2 -> type.
%mode extend-stp +A +B -D.

-/bot: extend-stp stp/bot _ stp/bot.
-/top: extend-stp stp/top _ stp/top.
-/arrow: extend-stp (stp/arrow S2 S1) _ (stp/arrow S2' S1')
        <- extend-stp S2 _ S2'
        <- extend-stp S1 _ S1'.
-/bind: extend-stp (stp/bind S2 S1) _ (stp/bind S2 S1).

%worlds () (extend-stp _ _ _).
%trustme
%total (A) (extend-stp A _ _).




%%%%%  Transivity and Narrowing  %%%%%

%{

(from Fsub proof)

The main proof for transitivity and narrowing.  The proof is by
induction on:

  (1st) the type Q
  (2nd) the clause, where we take trans* < narrow*
        (that is, narrow* can always call trans* with no change in Q,
    but when trans* calls narrow*, Q must decrease)
  (3rd) in trans*, the derivation of sub S Q,
        and in narrow*, the derivation of sub M N

Twelf requires that induction arguments be explicit, hence the first
two arguments to trans* and narrow*.  The third argument ensures that
the clause number is correct for the clause.  (That is, the clause
number is zero in trans* and one in narrow*).

}%






ttrans* : {J1:mode2}{J2:mode2}{J3:mode2}{G: tenv}{S: tp}{Q: tp}{T: tp}
      {Ncase:nat}
      nat_eq Ncase (s z)
%%
    -> stp oktrans J1 J2 G S Q
    -> stp oktrans J2 J3 G Q T
%%
    -> stp oktrans J1 J3 G S T
    -> type.

ttransdc* : {J1:mode2}{J2:mode2}{J3:mode2}{G: tenv}{S: dc}{Q: dc}{T: dc}
      {Ncase:nat}
      nat_eq Ncase (s z)
%%
     -> sdc oktrans J1 J2 G S Q
     -> sdc oktrans J2 J3 G Q T
%%
     -> sdc oktrans J1 J3 G S T
     -> type.


%mode ttrans*   +J1 +J2 +J3 +G +S +Q +T +C +E +X1 +X2 -X3.
%mode ttransdc* +J1 +J2 +J3 +G +S +Q +T +C +E +X1 +X2 -X3.

- : ttrans* _ _ _ _ _ _ _ _ _ S1 S2 (stp/trans S1 S2).

- : ttransdc*  _ _ _ _ _ _ _ _ nat_eq_ (sdc/rect L1 U1 X1 X2) (sdc/rect L2 U2 X2' X3) (sdc/rect L3 U3 X1 X3)
        <- ttrans* _ _ _ _ _ _ _ _ nat_eq_ L2 L1 L3
        <- ttrans* _ _ _ _ _ _ _ _ nat_eq_ U1 U2 U3.


%worlds () (ttrans* _ _ _ _ _ _ _ _ _ _ _ _).
%worlds () (ttransdc* _ _ _ _ _ _ _ _ _ _ _ _).

%trustme
%total (Q1) (ttrans* J1 J2 J3 G1 _ Q1 _ _ _ D1 E1 _).
%total (Q1') (ttransdc* J1' J2' J3' G1' _ Q1' _ _ _ D1' E1' _).


to-oktrans: stp notrans J1 J2 G T1 T2 -> stp oktrans J1 J2 G T1 T2 -> type.
%mode to-oktrans +A -B.
%worlds () (to-oktrans _ _).
%trustme
%total (A) (to-oktrans A _).


%{
trans* :
       stp notrans J1 nosel G S Q
    -> stp notrans nosel J3 G Q T
    -> stp notrans J1 J3 G S T
    -> type.


utrans0* : 
  {Ncase:nat}
  nat_eq Ncase z ->
  stp oktrans I1 I2 G T1 T2 -> 
  stp oktransnosel I1 I2 G T1 T2 -> 
  type.

utrans1* : 
  {Ncase:nat}
  nat_eq Ncase z ->
  stp oktrans I1 I2 G T1 T2 -> 
  stp oktransnosel I1 I2 G T1 T2 -> 
  type.


utrans* : 
  {Ncase:nat}
  nat_eq Ncase (s z) ->
  stp oktrans I1 I2 G T1 T2 -> 
  stp oktrans I2 I3 G T2 T3 -> 
  stp oktransnosel I1 I3 G T1 T3 -> 
  type.

%mode utrans0*  +N +E +J1 -G.
%mode utrans1*  +N +E +J1 -G.
%mode utrans*   +N +E +J1 +J3 -G.

- : utrans0* _ nat_eq_ stp/top stp/top.
- : utrans0* _ nat_eq_ stp/bot stp/bot.

- : utrans0* _ nat_eq_ (stp/sel1 D) (stp/sel1 D).
- : utrans0* _ nat_eq_ (stp/sel2 D1 D2 D3) (stp/sel2 D1 D2 D3).
- : utrans0* _ nat_eq_ (stp/arrow S1 S2) (stp/arrow S1 S2).
- : utrans0* _ nat_eq_ (stp/bind S1 S2) (stp/bind S1 S2).

- : utrans0* _ nat_eq_ (stp/trans S1 S2) S12 <- utrans* _ nat_eq_ S1 S2 S12.

- : utrans1* _ nat_eq_ stp/top stp/top.
- : utrans1* _ nat_eq_ stp/bot stp/bot.

- : utrans1* _ nat_eq_ (stp/sel1 D) (stp/sel1 D).
- : utrans1* _ nat_eq_ (stp/sel2 D1 D2 D3) (stp/sel2 D1 D2 D3).
- : utrans1* _ nat_eq_ (stp/arrow S1 S2) (stp/arrow S1 S2).
- : utrans1* _ nat_eq_ (stp/bind S1 S2) (stp/bind S1 S2).

- : utrans1* _ nat_eq_ (stp/trans S1 S2) S12 <- utrans* _ nat_eq_ S1 S2 S12.



- : utrans* _ nat_eq_ _ stp/top stp/top.
- : utrans* _ nat_eq_ stp/bot _ stp/bot.


- : utrans* _ nat_eq_ (stp/sel2 STL STU SLU) (stp/sel1 SUT) STT 
      <- utrans* _ nat_eq_ STU SUT STT.

- : utrans* _ nat_eq_ (stp/sel1 SUT) S2 (stp/sel1 (stp/trans SUT S2)).

- : utrans* _ nat_eq_ S1 (stp/sel2 STL STU SLU) (stp/sel2 (stp/trans S1 STL) (stp/trans S1 STU) SLU).


- : utrans* _ nat_eq_ S1 S2 (stp/trans2 S1' S2')
     <- utrans0* _ nat_eq_ S1 S1'
     <- utrans1* _ nat_eq_ S2 S2'.

%worlds () (utrans0* _ _ _ _)(utrans1* _ _ _ _)(utrans* _ _ _ _ _).
%total {[(A A')(A A')] (N N') } (utrans0* N _ A _)(utrans1* N'' _ B _)(utrans* N' _ A' B' _).




utrans* : {J1:mode2}{J3:mode2}{G: tenv}{S: tp}{Q: tp}{T: tp}
     {Ncase:nat}
     nat_eq Ncase z
%%
    -> stp notrans J1 oksel G S Q
    -> stp notrans oksel J3 G Q T
%%
    -> stp notrans J1 nosel G S Q
    -> stp notrans nosel J3 G S Q
    -> type.

%mode utrans*   +J1 +J3 +G +S +Q +T +C +E +X1 +X2 -X3 -X4.

% - : utrans (stp/sel1 (S1: stp oktrans oksel oksel (tcons _ G) T1))

}%




trans* : {J1:mode2}{J3:mode2}{G: tenv}{S: tp}{Q: tp}{T: tp}
     {Ncase:nat}
     nat_eq Ncase z
%%
    -> stp notrans J1 nosel G S Q
    -> stp notrans nosel J3 G Q T
%%
    -> stp notrans J1 J3 G S T
    -> type.

transdc* : {J1:mode2}{J3:mode2}{G: tenv}{S: dc}{Q: dc}{T: dc}
     {Ncase:nat}
     nat_eq Ncase z
%%
     -> sdc notrans J1 nosel G S Q
     -> sdc notrans nosel J3 G Q T
%%
     -> sdc notrans J1 J3 G S T
     -> type.


narrow* : {J1:mode2}{J3:mode2}{G:tenv}{P:dc}{Q:dc}{M:tp}{N:tp}
      {Ncase:nat}
      nat_eq Ncase (s z)
%%
      -> stp oktrans J1 J3 (tcons Q G) M N
      -> sdc oktrans oksel oksel G P Q
%%
      -> stp oktrans J1 J3 (tcons P G) M N -> type.

%mode trans*   +J1 +J3 +G +S +Q +T +C +E +X1 +X2 -X3.
%mode transdc* +J1 +J3 +G +S +Q +T +C +E +X1 +X2 -X3.
%mode narrow*  +J1 +J3 +G +P +Q +M +N +C +E +X1 +X2 -X3.

-rect   : transdc*  _ _ _ _ _ _ _ nat_eq_ (sdc/rect L1 U1 X1 X2) (sdc/rect L2 U2 X2' X3) (sdc/rect L3 U3 X1 X3)
        <- trans* _ _ _ _ _ _ _ nat_eq_ L2 L1 L3
        <- trans* _ _ _ _ _ _ _ nat_eq_ U1 U2 U3.

-top    : trans* _  _ _ _ _ _ _ _ stp/bot D stp/bot.

-top    : trans* _  _ _ _ _ _ _ _ D stp/top stp/top.


-var    : trans* _ _ _ _ _ _ _  nat_eq_ (stp/sel1 U2) D (stp/sel1 (stp/trans U2 D'))
        <- to-oktrans D D'.
%       <- trans* _  _ _ _ _ _ _  nat_eq_ U2 D U2'.

-var2   : trans* _ _ _ _ _ _ _  nat_eq_ D (stp/sel2 L2 U2) (stp/sel2 (stp/trans D' L2) U2)
        <- to-oktrans D D'.
%       <- trans* _ _ _ _ _ _ _  nat_eq_ D L2 L2'.


%{
-varx   :  trans* _ _ _ _ _ _ _ _ _ nat_eq_ (stp/sel2 T1L LU) (stp/sel1 UT2) T1T2
        <- trans* _ _ _ _ _ _ _ _ _ nat_eq_ T1L LU T1U
        <- trans* _ _ _ _ _ _ _ _ _ nat_eq_ T1U UT2 T1T2
        .
}%

-arrow  : trans* _ _ _ _ _ _ _ nat_eq_ (stp/arrow D1b D1a) (stp/arrow D2b D2a) 
            (stp/arrow (stp/trans D1b D2b) (stp/trans D2a D1a)).


-tbind  : trans* _ _ _ _ _ _ _ nat_eq_ (stp/bind D1b D1a) (stp/bind D2b D2a) (stp/bind (stp/trans D1b D2b') Da)
       <- ttransdc* _ _ _ _ _ _ _ _ nat_eq_ D1a D2a Da
       <- narrow* _ _ _ _ _ _ _ _ nat_eq_ D2b D1a D2b'.
%       <- trans* _ _ _ _ _ _ _ nat_eq_ D1b D2b' Db



-bot    : narrow* _ _ _ _ _ _ _ _ nat_eq_ stp/bot _ stp/bot.

-top    : narrow* _ _ _ _ _ _ _ _ nat_eq_ stp/top _ stp/top.


-trans  : narrow* _ _ _ _ _ _ _ _ nat_eq_ (stp/trans D1 D2) Dsub (stp/trans D1' D2')
       <- narrow* _ _ _ _ _ _ _ _ nat_eq_ D1 Dsub D1'
       <- narrow* _ _ _ _ _ _ _ _ nat_eq_ D2 Dsub D2'.

%{
-trans1  : narrow* _ _ _ _ _ _ _ _ nat_eq_ (stp/trans1 D1 D2) Dsub (stp/trans1 D1' D2')
       <- narrow* _ _ _ _ _ _ _ _ nat_eq_ D1 Dsub D1'
       <- narrow* _ _ _ _ _ _ _ _ nat_eq_ D2 Dsub D2'.
}%

-var    : narrow* _ _ _ _ _ _ _ _ nat_eq_ (stp/sel1 D) (sdc/rect Lsub Dsub X1 X2) (stp/sel1 (stp/trans Dsub' D'))
       <- extend-stp Dsub _ Dsub'
       <- narrow* _ _ _ _ _ _ _ _ nat_eq_ D (sdc/rect Lsub Dsub X1 X2) D'.
%       <- trans*  _ _ _ _ _ _ _ nat_eq_ Dsub' D' D''.


-var2   : narrow* _ _ _ _ _ _ _ _ nat_eq_ (stp/sel2 L D) (sdc/rect Lsub Dsub XX1 XX2) (stp/sel2 (stp/trans L' Lsub') XX1')
       <- extend-stp Lsub _ Lsub'
       <- extend-stp XX1 _ XX1'
       <- narrow* _ _ _ _ _ _ _ _ nat_eq_ L (sdc/rect Lsub Dsub XX1 XX2) L'.
%       <- trans*  _ _ _ _ _ _ _ nat_eq_ L' Lsub' L''.


-arrow  : narrow* _ _ _ _ _ _ _ _ nat_eq_ (stp/arrow (D2) (D1)) Dsub (stp/arrow (D2') (D1'))
       <- narrow* _ _ _ _ _ _ _ _ nat_eq_ D1 Dsub D1'
       <- narrow* _ _ _ _ _ _ _ _ nat_eq_ D2 Dsub D2'.


-bind   : narrow* _ _ _ _ _ _ _ _ nat_eq_ (stp/bind (D2) (D1)) Dsub (stp/bind (D2) (D1))
       % <- narrow* _ _ _ _ _ _ _ _ _ nat_eq_ D1 Dsub D1'
       % <- narrow* _ _ _ _ _ _ _ _ _ nat_eq_ (D2) Dsub (D2').
       .


%worlds () 
(trans* _ _ _ _ _ _ _ _ _ _ _)
(transdc* _ _ _ _ _ _ _ _ _ _ _)
(narrow* _ _ _ _ _ _ _ _ _ _ _ _).

%total {(Q1 Q1' Q1'') (N1 N1' N1'') (D1 D1' D1'') (E1 E1' E1'')} 
(trans* J1 J3 G1 _ Q1 _ N1 _ D1 E1 _) 
(transdc* J1' J3' G1' _ Q1' _ N1' _ D1' E1' _)
(narrow* J1'' J3'' G1'' P1'' Q1'' _ _ N1'' _ D1'' E1'' _).



%.


%%%%%  Peroration  %%%%%

trans : sub I IS IQ G S Q -> sub I IQ IT G Q T -> sub I IS IT G S T -> type.
%mode trans +X1 +X2 -X3.

-   : trans D1 D2 D3
       <- trans* _ _ _ _ _ _ _ _ _ nat_eq_ D1 D2 D3.

%worlds () (trans _ _ _).
%total {} (trans _ _ _).



narrow : sub IG IM IN (tcons Q I G) M N -> sdc IG I I G P Q -> sub IG IM IN (tcons P I G) M N -> type.
%mode narrow +X1 +X2 -X3.

-   : narrow D1 D2 D3
       <- narrow* _ _ _ _ _ _ _ _ _ _ nat_eq_ D1 D2 D3.

%worlds () (narrow _ _ _).
%total {} (narrow _ _ _).

