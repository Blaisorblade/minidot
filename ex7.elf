%{
DOT (Dependent Object Types) from the bottom up
}%

%%%%%  Natural Numbers  %%%%%

nat : type.  %name nat N.

0 : nat.
s : nat -> nat.

nat-eq : nat -> nat -> type.
nat-eq/i : nat-eq N N.

nat-neq : nat -> nat -> type.
nat-neq/zs : nat-neq 0 (s _).
nat-neq/sz : nat-neq (s _) 0.
nat-neq/ss : nat-neq (s N1) (s N2)
          <- nat-neq N1 N2.

lt : nat -> nat -> type.
lt/z		: lt 0 (s _).
lt/s		: lt (s N1) (s N2)
		   <- lt N1 N2.

gt : nat -> nat -> type.
gt/z    : gt (s _) 0.
gt/s    : gt (s N1) (s N2)
       <- gt N1 N2.

plus : nat -> nat -> nat -> type.
plus/z : plus 0 N N.
plus/s : plus (s N1) N2 (s N3)
      <- plus N1 N2 N3.
%reduces N <= N' (plus _ N N').

sum-inc : {N1}{N2}{N3} plus N1 N2 N3 -> plus N1 (s N2) (s N3) -> type.
%mode sum-inc +X1 +X2 +X3 +X4 -X5.

-: sum-inc _ _ _ plus/z plus/z.

-: sum-inc _ _ _ (plus/s D) (plus/s D')
    <- sum-inc _ _ _ D D'.

%worlds () (sum-inc _ _ _ _ _).
%total (D) (sum-inc _ _ _ D _).

commute' : {N1}{N2}{N3}plus N1 N2 N3 -> plus N2 N1 N3 -> type.
%mode commute' +X1 +X2 +X3 +X4 -X5.

-: commute' 0 (s M) _ plus/z (plus/s D)
    <- commute' 0 M _ plus/z D.

-: commute' _ 0 _ _ plus/z.

-: commute' (s N1) N2 _ (plus/s D) D''
    <- commute' N1 N2 _ D D'
    <- sum-inc _ _ _ D' D''.

%worlds () (commute' _ _ _ _ _).
%total [N1 N2] (commute' N1 N2 _ _ _).

assoc : plus N1 N2 N3 
	 -> plus N3 N4 N
	 -> plus N2 N4 N5
	 -> plus N1 N5 N
	 -> type.
%mode assoc +X1 +X2 -X3 -X4.

-: assoc plus/z D D plus/z.

-: assoc (plus/s Da) (plus/s Db) Da' (plus/s Db')
    <- assoc Da Db Da' Db'. 

%worlds () (assoc _ _ _ _).
%total (D) (assoc D _ _ _).
			   
assoc' : plus N1 N2 N3
	  -> plus N4 (s N3) N
	  -> plus N4 N2 N5
	  -> plus N1 (s N5) N
	  -> type.
%mode assoc' +X1 +X2 -X3 -X4.

-: assoc' D1 D2 D3 D4
    <- commute' _ _ _ D2 D2'
    <- assoc (plus/s D1) D2' D3' (plus/s D4')
    <- commute' _ _ _ D3' D3
    <- sum-inc _ _ _ D4' D4.

%worlds () (assoc' _ _ _ _).
%total(D) (assoc' D _ _ _).

add : {N1}{N2} plus N1 N2 N3 -> type.
%mode add +X1 +X2 -X3.

-: add 0 N2 plus/z.

-: add (s N1) N2 (plus/s D)
    <- add N1 N2 D.

%worlds () (add _ _ _).
%total (N) (add N _ _).

%%%%% Labels %%%%%

label : type.  %name label L.
label/nat : nat -> label.

label-eq   : label -> label -> type.
label-eq/i : label-eq L L.

label-neq  : label -> label -> type.
label-neq/nat : label-neq (label/nat N1) (label/nat N2)
             <- nat-neq N1 N2.

label-less : label -> label -> type.
label-less/nat : label-less (label/nat N1) (label/nat N2)
              <- lt N1 N2.

label-more : label -> label -> type.
label-more/nat : label-more (label/nat N1) (label/nat N2)
              <- gt N1 N2.

%%%%% Syntax %%%%%

tp    : type.  %name tp A.
exp   : type.  %name exp M.
decls : type.  %name decls D.

o       : tp.
top     : tp.
bot     : tp.
tsel    : exp -> label -> tp.
arrow   : decls -> tp -> tp -> tp.
and     : tp -> tp -> tp.
or      : tp -> tp -> tp.

b       : exp.
lam     : decls -> tp -> (exp -> exp) -> exp.
app     : exp -> exp -> exp.

dnil    : decls.
dcons   : decls -> label -> tp -> tp -> decls.

%%%%% Declarations %%%%%

dlookup : decls -> label -> tp -> tp -> type. %name dlookup DL.
dlookup/hit  : dlookup (dcons D L S U) L S U.
dlookup/miss : dlookup (dcons D _ _ _) L S U
                <- dlookup D L S U.

dordered : decls -> type.          %name dordered OD.
dbounded : decls -> label -> type. %name dbounded BD.

dordered/nil     : dordered dnil.

dordered/cons    : dordered (dcons D L _ _)
                   <- dbounded D L.

dbounded/nil     : dbounded dnil L.

dbounded/cons    : dbounded (dcons D LY _ _) LX
                   <- label-less LY LX
                   <- dbounded D LY.

%%%%%  Contexts  %%%%%

isvar   : exp -> nat -> type.
%{
The assumption "isvar X I" indicates that the expression X is a variable
and carries order stamp I.
}%

%{
Isvar will be frozen shortly.  Make it depend on itself while we still can.
}%
-       : (isvar _ _ -> isvar _ _) -> type.


ctx     : type.  %name ctx G.

nil     : ctx.
cons    : ctx -> exp -> tp -> ctx.



precedes : exp -> exp -> type.

precedes/i      : precedes X Y
                   <- isvar X I
                   <- isvar Y J
                   <- lt I J.



ordered : ctx -> type.        %name ordered OG.
bounded : ctx -> exp -> type. %name bounded BG.
%{
"ordered G" means that the assumptions are listed in increasing order by stamp.
"bounded G X" means that G is ordered and all assumptions are less than X.
}%

ordered/nil     : ordered nil.

ordered/cons    : ordered (cons G X _)
                   <- bounded G X.

bounded/nil     : bounded nil X
                   <- isvar X _.

bounded/cons    : bounded (cons G Y _) X
                   <- precedes Y X
                   <- bounded G Y.



lookup : ctx -> exp -> tp -> type. %name lookup L.

lookup/hit      : lookup (cons G X A) X A.

lookup/miss     : lookup (cons G Y _) X A
                   <- lookup G X A.



append : ctx -> ctx -> ctx -> type.

append/nil      : append G nil G.

append/cons     : append G1 (cons G2 X A) (cons G X A)
                   <- append G1 G2 G.

sub-ctx : ctx -> ctx -> type.

sub-ctx/nil      : sub-ctx G G.
sub-ctx/cons     : sub-ctx G1 (cons G2 X A)
              <- sub-ctx G1 G2
              <- ordered (cons G2 X A).

%%%%%  Typing Rules (Explicit Context) %%%%%

expand       : ctx -> tp -> decls -> type. %name expand EX.

expand/arrow : expand G (arrow D _ _) D
          <- dordered D.


pev       : ctx -> exp -> label -> tp -> tp -> type.  %name pev P.
wft       : ctx -> tp -> type.                        %name wft WT.
sub       : ctx -> tp -> ctx -> tp -> type.           %name sub B.
sub-decls : ctx -> decls -> ctx -> decls -> type.     %name sub-decls BD.
wf-decls  : ctx -> decls -> type.                     %name wf-decls WD.

pev/a     : pev G X L AS AU
       <- sub G AS G AU
       <- wft G AS
       <- wft G AU
       <- dlookup D L AS AU
       <- expand G A D
       <- lookup G X A
       <- ordered G.

sub/o     : sub G1 o G2 o.
sub/top   : sub G1 A G2 top
       <- wft G1 A.
sub/bot   : sub G1 bot G2 A
       <- wft G2 A.
sub/arrow : sub G1 (arrow D1 AS1 AU1) G2 (arrow D2 AS2 AU2)
       <- sub-decls G1 D1 G2 D2
       <- sub G2 AS2 G1 AS1
       <- sub G1 AU1 G2 AU2.
sub/tsel1 : sub G1 (tsel X1 L1) G2 A2
       <- sub G1 AU1 G2 A2
       <- pev G1 X1 L1 AS1 AU1.
sub/tsel2 : sub G1 A1 G2 (tsel X2 L2)
       <- sub G1 A1 G2 AS2
       <- pev G2 X2 L2 AS2 AU2.
sub/tselx : sub G1 (tsel X L) G2 (tsel X L)
       <- sub-ctx G G2
       <- sub-ctx G G1
       <- pev G X L AS AU
       <- sub-decls G2 (dcons dnil L AS AU) G1 (dcons dnil L AS AU)
       <- sub-decls G1 (dcons dnil L AS AU) G2 (dcons dnil L AS AU).
sub/and1l : sub G1 (and T1L T1R) G2 T2
       <- wft G1 T1R
       <- sub G1 T1L G2 T2.
sub/and1r : sub G1 (and T1L T1R) G2 T2
       <- wft G1 T1L
       <- sub G1 T1R G2 T2.
sub/and2  : sub G1 T1 G2 (and T2L T2R)
       <- sub G1 T1 G2 T2L
       <- sub G1 T1 G2 T2R.
sub/or2l : sub G1 T1 G2 (or T2L T2R)
       <- wft G2 T2R
       <- sub G1 T1 G2 T2L.
sub/or2r : sub G1 T1 G2 (or T2L T2R)
       <- wft G2 T2L
       <- sub G1 T1 G2 T2R.
sub/or1  : sub G1 (or T1L T1R) G2 T1
       <- sub G1 T1L G2 T2
       <- sub G1 T1R G2 T2.


sub-decls/nil  : sub-decls G1 D1 G2 dnil
              <- wf-decls G1 D1.

sub-decls/cons-hit : sub-decls G1 (dcons D1 L AS1 AU1) G2 (dcons D2 L AS2 AU2)
              <- sub G1 AS1 G1 AU1
              <- sub G2 AS2 G2 AU2
              <- sub G2 AS2 G1 AS1
              <- sub G1 AU1 G2 AU2
              <- sub-decls G1 D1 G2 D2
              <- dbounded D1 L
              <- dbounded D2 L.

sub-decls/cons-miss : sub-decls G1 (dcons D1 L1 AS1 AU1) G2 (dcons D2 L2 AS2 AU2)
              <- sub-decls G1 D1 G2 (dcons D2 L2 AS2 AU2)
              <- wf-decls G1 (dcons D1 L1 AS1 AU1)
              <- dbounded (dcons D2 L2 AS2 AU2) L1.

wft/o     : wft G o.
wft/top   : wft G top.
wft/bot   : wft G bot.
wft/arrow : wft G (arrow D AS AU)
       <- wf-decls G D
       <- wft G AS
       <- wft G AU.
wft/tsel  : wft G (tsel X L)
       <- pev G X L AS AU.
wft/and   : wft G (and TL TR)
       <- wft G TL
       <- wft G TR.
wft/or    : wft G (or TL TR)
       <- wft G TL
       <- wft G TR.

wf-decls/nil  : wf-decls G dnil.
wf-decls/cons : wf-decls G (dcons D L AS AU)
       <- wft G AS
       <- wft G AU
       <- sub G AS G AU
       <- wf-decls G D
       <- dbounded D L.

of        : ctx -> exp -> tp -> type.  %name of T.

of/b      : of G b o.

of/var		: of G X A
		   <- lookup G X A
       <- ordered G
       <- wft G A
       <- isvar X I.

of/lam : of G (lam D A ([x] M x)) (arrow D A B)
		   <- ({x}{d:isvar x I} of (cons G x A) (M x) B)
       <- ({x}{d:isvar x I} ordered (cons G x A))
       <- wft G (arrow D A B).

of/app		: of G (app M N) B
		   <- of G N A
		   <- of G M (arrow D A B).

of/sub    : of G M A'
       <- of G M A
       <- sub G A G A'.

%query 1 1 wf-decls nil dnil.
0l  = label/nat 0.
1ds = dcons dnil 0l o o.
%query 1 1 wf-decls nil 1ds.
%query 1 1 of nil (app (lam dnil o ([x] (lam dnil o ([y] x)))) b) (arrow dnil o o).
%query 1 1 of nil (app (lam dnil o ([x] (lam 1ds o ([y] x)))) b) (arrow 1ds o o).
%query 1 1 of nil (app (lam dnil o ([x] (lam dnil o ([y] x)))) b) (arrow dnil bot top).
%query 1 1 of nil (lam dnil (arrow 1ds o o) ([x] (lam dnil (tsel x 0l) ([y] y)))) (arrow dnil (arrow 1ds o o) top).
%query 1 1 of nil (lam dnil (arrow 1ds o o) ([x] (lam dnil (tsel x 0l) ([y] y)))) (arrow dnil (arrow 1ds o o) (arrow dnil bot top)).
%query 1 1 of nil (lam dnil (arrow 1ds o o) ([x] (lam dnil (tsel x 0l) ([y] y)))) (arrow dnil (arrow 1ds o o) (arrow dnil o o)).

%%%%%  Worlds  %%%%%

%block var	: block {x:exp}.

%block ovar	: some {i:nat}
		   block 
		   {x:exp}
		   {d:isvar x i}.




%%%%%  Equality  %%%%%

ctx-eq : ctx -> ctx -> type.
ctx-eq/i : ctx-eq G G.

exp-eq : exp -> exp -> type.
exp-eq/i : exp-eq M M.

tp-eq : tp -> tp -> type.
tp-eq/i : tp-eq A A.

decls-eq : decls -> decls -> type.
decls-eq/i : decls-eq D D.

lt-resp : nat-eq N1 N1' -> nat-eq N2 N2' -> lt N1 N2 -> lt N1' N2' -> type.
%mode lt-resp +D1 +D2 +D3 -D.

-	: lt-resp nat-eq/i nat-eq/i D D.

%worlds () (lt-resp _ _ _ _).
%total {} (lt-resp _ _ _ _).



of-resp : ctx-eq G G' -> exp-eq M M' -> tp-eq A A' -> of G M A -> of G' M' A' -> type.
%mode of-resp +X1 +X2 +X3 +X4 -X5.

-       : of-resp ctx-eq/i exp-eq/i tp-eq/i D D.

%worlds (var | ovar) (of-resp _ _ _ _ _).
%total {} (of-resp _ _ _ _ _).




%%%%%  Reductio Ad Absurdum  %%%%%

false : type.


false-implies-of : false -> of G M A -> type.
%mode +{G:ctx} +{M:exp} +{A:tp} +{X1:false} -{X2:of G M A} (false-implies-of X1 X2).
%worlds (var | ovar) (false-implies-of _ _).
%total {} (false-implies-of _ _).


false-implies-tp-eq : false -> tp-eq A B -> type.
%mode +{A:tp} +{B:tp} +{X1:false} -{X2:tp-eq A B} (false-implies-tp-eq X1 X2).
%worlds (var | ovar) (false-implies-tp-eq _ _).
%total {} (false-implies-tp-eq _ _).


false-implies-bounded : false -> bounded G X -> type.
%mode +{G:ctx} +{X:exp} +{X1:false} -{X2:bounded G X} (false-implies-bounded X1 X2).
%worlds (var | ovar) (false-implies-bounded _ _).
%total {} (false-implies-bounded _ _).


false-implies-ordered : false -> ordered G -> type.
%mode +{G:ctx} +{X1:false} -{X2:ordered G} (false-implies-ordered X1 X2).
%worlds (var | ovar) (false-implies-ordered _ _).
%total {} (false-implies-ordered _ _).




%%%%%  Lt  %%%%%

lt-trans : lt N1 N2 -> lt N2 N3 -> lt N1 N3 -> type.
%mode lt-trans +D1 +D2 -D3.

-	: lt-trans lt/z (lt/s _) lt/z.

-	: lt-trans (lt/s D1) (lt/s D2) (lt/s D3)
	   <- lt-trans D1 D2 D3.

%worlds () (lt-trans _ _ _).
%total D (lt-trans D _ _).



lt-antisymm : lt N N -> false -> type.
%mode lt-antisymm +X1 -X2.

-	: lt-antisymm (lt/s D) D'
	   <- lt-antisymm D D'.

%worlds () (lt-antisymm _ _).
%total D (lt-antisymm D _).



lt-succ : {N} lt N (s N) -> type.
%mode lt-succ +X1 -X2.

-	: lt-succ 0 lt/z.

-	: lt-succ (s N) (lt/s D)
	   <- lt-succ N D.

%worlds () (lt-succ _ _).
%total N (lt-succ N _).




%%%%%  Ordered Variable Lemmas  %%%%%

isvar-fun : isvar X I -> isvar X J -> nat-eq I J -> type.
%mode isvar-fun +X1 +X2 -X3.

-	:  isvar-fun D D nat-eq/i.

%worlds (ovar) (isvar-fun _ _ _).
%total {} (isvar-fun _ _ _).

isvar-fun-eq : isvar X I -> exp-eq X X' -> isvar X' I -> type.
%mode isvar-fun-eq +X1 +X2 -X3.

-	:  isvar-fun-eq D exp-eq/i D.

%worlds (ovar) (isvar-fun-eq _ _ _).
%total {} (isvar-fun-eq _ _ _).



precedes-trans : precedes X Y -> precedes Y Z -> precedes X Z -> type.
%mode precedes-trans +X1 +X2 -X3.

-       : precedes-trans
           (precedes/i
              (DltIJ : lt I J)
              (DisvarY : isvar Y J)
              (DisvarX : isvar X I))
           (precedes/i
              (DltJ'K : lt J' K)
              (DisvarZ : isvar Z K)
              (DisvarY' : isvar Y J'))
           (precedes/i DltIK DisvarZ DisvarX)
           <- isvar-fun DisvarY' DisvarY 
              (Deq : nat-eq J' J)
           <- lt-resp Deq nat-eq/i DltJ'K
              (DltJK : lt J K)
           <- lt-trans DltIJ DltJK
              (DltIK : lt I K).

%worlds (ovar) (precedes-trans _ _ _).
%total {} (precedes-trans _ _ _).



precedes-irreflex : precedes X X -> false -> type.
%mode precedes-irreflex +X1 -X2.

-       : precedes-irreflex 
	   (precedes/i 
	      (Dlt : lt I J)
	      (D2 : isvar X J)
	      (D1 : isvar X I))
	   Dfalse
           <- isvar-fun D1 D2 (Deq : nat-eq I J)
           <- lt-resp Deq nat-eq/i Dlt (Dlt' : lt J J)
           <- lt-antisymm Dlt' Dfalse.

%worlds (ovar) (precedes-irreflex _ _).
%total {} (precedes-irreflex _ _).

precedes-eq-irreflex : precedes X Y -> exp-eq X Y -> false -> type.
%mode precedes-eq-irreflex +X1 +X2 -X3.

-       : precedes-eq-irreflex 
	   (precedes/i 
	      (Dlt : lt I J)
	      (D2 : isvar Y J)
	      (D1 : isvar X I))
     DEeq
	   Dfalse
           <- isvar-fun-eq D1 DEeq D2'
           <- isvar-fun D2' D2 (Deq : nat-eq I J)
           <- lt-resp Deq nat-eq/i Dlt (Dlt' : lt J J)
           <- lt-antisymm Dlt' Dfalse.

%worlds (ovar) (precedes-eq-irreflex _ _ _).
%total {} (precedes-eq-irreflex _ _ _).


bounded-isvar : bounded G X -> isvar X I -> type.
%mode bounded-isvar +X1 -X2.

-       : bounded-isvar (bounded/nil D) D.

-       : bounded-isvar (bounded/cons _ (precedes/i _ D _)) D.

%worlds (ovar) (bounded-isvar _ _).
%total {} (bounded-isvar _ _).


isvar-not-b   : isvar b I -> false -> type.
%mode isvar-not-b +X1 -X2.
%worlds (ovar) (isvar-not-b _ _).
%total {} (isvar-not-b _ _).

isvar-not-lam : isvar (lam D A M) I -> false -> type.
%mode isvar-not-lam +X1 -X2.
%worlds (ovar) (isvar-not-lam _ _).
%total {} (isvar-not-lam _ _).



isvar-not-app : isvar (app M N) I -> false -> type.
%mode isvar-not-app +X1 -X2.
%worlds (ovar) (isvar-not-app _ _).
%total {} (isvar-not-app _ _).




%%%%%  Explicit Context Lemmas  %%%%%

bounded-is-ordered : bounded G X 
%%
		      -> ordered G
		      -> type.
%mode bounded-is-ordered +X1 -X2.

-       : bounded-is-ordered (bounded/nil _) ordered/nil.

-       : bounded-is-ordered (bounded/cons D _) (ordered/cons D).

%worlds (ovar) (bounded-is-ordered _ _).
%total {} (bounded-is-ordered _ _).



bounded-increase : bounded G X
                    -> precedes X Y
%%
                    -> bounded G Y 
		    -> type.
%mode bounded-increase +X1 +X2 -X3.

-       : bounded-increase
           (bounded/nil _)
           (precedes/i _ D _)
           (bounded/nil D).

-       : bounded-increase
           (bounded/cons 
              (Dbounded : bounded G Z)
              (DprecZX : precedes Z X))
           (DprecXY : precedes X Y)
           (bounded/cons Dbounded DprecZY)
           <- precedes-trans DprecZX DprecXY
              (DprecZY : precedes Z Y).

%worlds (ovar) (bounded-increase _ _ _).
%total {} (bounded-increase _ _ _).



append-bounded : append G1 G2 G
		  -> bounded G X
%%
		  -> bounded G1 X 
		  -> type.
%mode append-bounded +X1 +X2 -X3.

-	: append-bounded append/nil D D.

-	: append-bounded
	   (append/cons 
	      (Dappend : append G1 G2 G))
	   (bounded/cons
	      (Dbounded : bounded G Y)
	      (Dprecedes : precedes Y X))
	   Dbounded''
	   <- append-bounded Dappend Dbounded 
	      (Dbounded' : bounded G1 Y)
	   <- bounded-increase Dbounded' Dprecedes 
	      (Dbounded'' : bounded G1 X).

%worlds (ovar) (append-bounded _ _ _).
%total D (append-bounded D _ _).



extend-context : ordered G
%%
		  -> ({x} isvar x I -> bounded G x)
		  -> type.
%mode extend-context +X1 -X2.

-       : extend-context ordered/nil ([x] [d:isvar x 0] bounded/nil d).

-       : extend-context
           (ordered/cons (Dbounded : bounded G Y))
           ([x] [d:isvar x (s J)] bounded/cons Dbounded (precedes/i Dlt d Disvar))
           <- bounded-isvar Dbounded
              (Disvar : isvar Y J)
           <- lt-succ J (Dlt : lt J (s J)).

%worlds (ovar) (extend-context _ _).
%total {} (extend-context _ _).



ordered-car : ordered (cons G X A) 
%%
	       -> isvar X I
	       -> type.
%mode ordered-car +X1 -X2.

-	: ordered-car 
	   (ordered/cons 
	      (Dbounded : bounded G X))
	   Disvar
	   <- bounded-isvar Dbounded (Disvar : isvar X I).

%worlds (ovar) (ordered-car _ _).
%total {} (ordered-car _ _).



ordered-cdr : ordered (cons G X A) 
%%
	       -> ordered G 
	       -> type.
%mode ordered-cdr +X1 -X2.

-	: ordered-cdr 
	   (ordered/cons 
	      (Dbounded : bounded G X)) 
	   Dordered
	   <- bounded-is-ordered Dbounded 
	      (Dordered : ordered G).

%worlds (ovar) (ordered-cdr _ _).
%total {} (ordered-cdr _ _).



lookup-ordered : lookup G X A
		  -> ordered G
		  -> isvar X I 
		  -> type.
%mode lookup-ordered +X1 +X2 -X3.

-	: lookup-ordered 
	   lookup/hit 
	   (Dordered : ordered (cons G X A))
	   Disvar
	   <- ordered-car Dordered (Disvar : isvar X I).

-	: lookup-ordered 
	   (lookup/miss 
	      (Dlookup : lookup G X A))
	   (Dordered : ordered (cons G Y B))
	   Disvar
	   <- ordered-cdr Dordered (Dordered' : ordered G)
	   <- lookup-ordered Dlookup Dordered' (Disvar : isvar X I).

%worlds (ovar) (lookup-ordered _ _ _).
%total D (lookup-ordered D _ _).



bounded-contra : bounded (cons G X A) X 
%%
		  -> false
		  -> type.
%mode bounded-contra +X1 -X2.

-	: bounded-contra 
	   (bounded/cons _ (Dprecedes : precedes X X))
	   Dfalse
	   <- precedes-irreflex Dprecedes Dfalse.

%worlds (ovar) (bounded-contra _ _).
%total {} (bounded-contra _ _).

bounded-eq-contra : bounded (cons G X A) Y
                     -> exp-eq X Y
%%
		  -> false
		  -> type.
%mode bounded-eq-contra +X1 +X2 -X3.

-	: bounded-eq-contra 
	   (bounded/cons _ (Dprecedes : precedes X Y))
     Deq
	   Dfalse
	   <- precedes-eq-irreflex Dprecedes Deq Dfalse.

%worlds (ovar) (bounded-eq-contra _ _ _).
%total {} (bounded-eq-contra _ _ _).

lookup-bounded-contra : lookup G X A
			 -> bounded G X
%%
			 -> false 
			 -> type.
%mode lookup-bounded-contra +X1 +X2 -X3.

-       : lookup-bounded-contra 
	   lookup/hit
	   (Dbounded : bounded (cons G X A) X)
	   Dfalse
           <- bounded-contra Dbounded Dfalse.

-       : lookup-bounded-contra 
	   (lookup/miss 
	      (Dlookup : lookup G X A))
	   (bounded/cons
	      (Dbounded : bounded G Y)
	      (Dprecedes : precedes Y X))
	   Dfalse
           <- bounded-increase Dbounded Dprecedes (Dbounded' : bounded G X)
           <- lookup-bounded-contra Dlookup Dbounded' Dfalse.

%worlds (ovar) (lookup-bounded-contra _ _ _).
%total D (lookup-bounded-contra D _ _).

lookup-eq-bounded-contra : lookup G X A
			 -> bounded G Y
       -> exp-eq X Y
%%
			 -> false 
			 -> type.
%mode lookup-eq-bounded-contra +X1 +X2 +X3 -X4.

-       : lookup-eq-bounded-contra 
	   lookup/hit
	   (Dbounded : bounded (cons G X A) Y)
     Deq
	   Dfalse
           <- bounded-eq-contra Dbounded Deq Dfalse.

-       : lookup-eq-bounded-contra 
	   (lookup/miss 
	      (Dlookup : lookup G X A))
	   (bounded/cons
	      (Dbounded : bounded G Y)
	      (Dprecedes : precedes Y X))
     Deq
	   Dfalse
           <- bounded-increase Dbounded Dprecedes (Dbounded' : bounded G X)
           <- lookup-eq-bounded-contra Dlookup Dbounded' Deq Dfalse.

%worlds (ovar) (lookup-eq-bounded-contra _ _ _ _).
%total D (lookup-eq-bounded-contra D _ _ _).

append-lookup-eq : ({x} append (cons G1 x A) (G2 x) (G x))
		    -> ({x} isvar x I -> ordered (G x))
		    -> ({x} lookup (G x) x (B x))
%%
		    -> ({x} tp-eq A (B x)) 
		    -> type.
%mode append-lookup-eq +X1 +X2 +X3 -X4.

-       : append-lookup-eq _ _ ([x] lookup/hit) ([_] tp-eq/i).

-       : append-lookup-eq 
	   ([x] 
	      append/cons 
	      (Dappend x : append (cons G1 x A) (G2 x) (G x)))
	   ([x] [d:isvar x I] 
	      Dordered x d : ordered (cons (G x) (Y x) (C x)))
	   ([x] 
	      lookup/miss (Dlookup x : lookup (G x) x (B x)))
           Deq
	   <- ({x} {d:isvar x I}
		 ordered-cdr (Dordered x d) (Dordered' x d : ordered (G x)))
           <- append-lookup-eq Dappend Dordered' Dlookup (Deq : {x} tp-eq A (B x)).

-       : append-lookup-eq 
	   ([x] append/nil) 
	   ([x] [d:isvar x I]
	      ordered/cons (Dbounded x d : bounded G1 x))
	   ([x] 
	      lookup/miss (Dlookup x : lookup G1 x (B x)))
           Deq
           <- ({x} {d:isvar x I}
                 lookup-bounded-contra (Dlookup x) (Dbounded x d) Dfalse)
           <- ({x} false-implies-tp-eq Dfalse (Deq x)).

-	: append-lookup-eq 
	   ([x] 
	      append/cons 
	      (Dappend x : append (cons G1 x A) (G2 x) (G x)))
	   ([x] [d:isvar x I]
	      ordered/cons (Dbounded x d : bounded (G x) x))
	   ([x] lookup/hit)
	   Deq
	   <- ({x} {d:isvar x I}
		 append-bounded (Dappend x) (Dbounded x d) 
		 (Dbounded' x d : bounded (cons G1 x A) x))
	   <- ({x} {d:isvar x I}
		 bounded-contra (Dbounded' x d) Dfalse)
	   <- ({x} false-implies-tp-eq Dfalse (Deq x)).

%worlds (ovar) (append-lookup-eq _ _ _ _).
%total D (append-lookup-eq D _ _ _).



%% Lookup is preserved under deletion of other variables.
lookup-pdv : ({x} append (cons G1 x A) (G2 x) (G x))
               -> append G1 (G2 M) G'
               -> ({x} lookup (G x) Y (B x))
%%
               -> lookup G' Y (B M) 
	       -> type.
%mode lookup-pdv +X1 +X2 +X3 -X4.

-       : lookup-pdv 
	   ([x] append/cons 
	      (Dappend x : append (cons G1 x A) (G2 x) (G x)))
	   (append/cons 
	      (Dappend' : append G1 (G2 M) G'))
	   ([x] lookup/hit)
	   %%
           lookup/hit.

-       : lookup-pdv
	   ([x] append/cons 
	      (Dappend x : append (cons G1 x A) (G2 x) (G x)))
	   (append/cons 
	      (Dappend' : append G1 (G2 M) G'))
	   ([x] 
	      lookup/miss 
	      (Dlookup x : lookup (G x) Y (B x)))
	   %%
           (lookup/miss Dlookup')
           <- lookup-pdv Dappend Dappend' Dlookup Dlookup'.

-       : lookup-pdv 
	   ([x] append/nil) 
	   append/nil 
	   ([x] lookup/miss 
	      (Dlookup x : lookup _ _ (B x)))
	   %%
           (Dlookup M).

%worlds (ovar) (lookup-pdv _ _ _ _).
%total D (lookup-pdv D _ _ _).




%%%%%  Weakening  %%%%%

weaken-lookup-gen : append G1 G2 G
                     -> append (cons G1 X A) G2 G'
                     -> lookup G Y B
%%
                     -> lookup G' Y B 
		     -> type.
%mode weaken-lookup-gen +X1 +X2 +X3 -X4.

-       : weaken-lookup-gen (append/cons _) (append/cons _) lookup/hit lookup/hit.

-       : weaken-lookup-gen (append/cons Dappend) (append/cons Dappend') (lookup/miss Dlookup)
           (lookup/miss Dlookup')
           <- weaken-lookup-gen Dappend Dappend' Dlookup Dlookup'.

-       : weaken-lookup-gen append/nil append/nil Dlookup (lookup/miss Dlookup).

%worlds (var) (weaken-lookup-gen _ _ _ _).
%total D (weaken-lookup-gen D _ _ _).




%%%%%  Values  & Stacks %%%%%

val      : type.  %name val V.
vctx     : type.  %name vctx H.

v        : val.
clo      : vctx -> (exp -> exp) -> val.
bin      : (exp -> val) -> val.
vnil     : vctx.
vcons    : vctx -> exp -> val -> vctx.

val-eq : val -> val -> type.
val-eq/i : val-eq A A.

false-implies-val-eq : false -> val-eq A B -> type.
%mode +{A:val} +{B:val} +{X1:false} -{X2:val-eq A B} (false-implies-val-eq X1 X2).
%worlds (var | ovar) (false-implies-val-eq _ _).
%total {} (false-implies-val-eq _ _).

vordered : vctx -> type.        %name vordered OH.
vbounded : vctx -> exp -> type. %name vbounded BH.
%{
"ordered G" means that the assumptions are listed in increasing order by stamp.
"bounded G X" means that G is ordered and all assumptions are less than X.
}%

vordered/nil    : vordered vnil.

vordered/cons   : vordered (vcons H X _)
                   <- vbounded H X.

vbounded/nil    : vbounded vnil X
                   <- isvar X _.

vbounded/cons   : vbounded (vcons H Y _) X
                   <- precedes Y X
                   <- vbounded H Y.



vlookup : vctx -> exp -> val -> type.

vlookup/hit     : vlookup (vcons H X V) X V.

vlookup/miss    : vlookup (vcons H Y _) X V
                   <- vlookup H X V.



vappend : vctx -> vctx -> vctx -> type.

vappend/nil      : vappend H vnil H.

vappend/cons     : vappend H1 (vcons H2 X V) (vcons H X V)
                   <- vappend H1 H2 H.


%%%%%  Explicit Stack Lemmas  %%%%%

vbounded-isvar : vbounded H X -> isvar X I -> type.
%mode vbounded-isvar +X1 -X2.

-       : vbounded-isvar (vbounded/nil D) D.

-       : vbounded-isvar (vbounded/cons _ (precedes/i _ D _)) D.

%worlds (ovar) (vbounded-isvar _ _).
%total {} (vbounded-isvar _ _).

vbounded-is-vordered : vbounded H X 
%%
		      -> vordered H
		      -> type.
%mode vbounded-is-vordered +X1 -X2.

-       : vbounded-is-vordered (vbounded/nil _) vordered/nil.

-       : vbounded-is-vordered (vbounded/cons D _) (vordered/cons D).

%worlds (ovar) (vbounded-is-vordered _ _).
%total {} (vbounded-is-vordered _ _).



vbounded-increase : vbounded H X
                    -> precedes X Y
%%
                    -> vbounded H Y 
		    -> type.
%mode vbounded-increase +X1 +X2 -X3.

-       : vbounded-increase
           (vbounded/nil _)
           (precedes/i _ D _)
           (vbounded/nil D).

-       : vbounded-increase
           (vbounded/cons 
              (Dvbounded : vbounded H Z)
              (DprecZX : precedes Z X))
           (DprecXY : precedes X Y)
           (vbounded/cons Dvbounded DprecZY)
           <- precedes-trans DprecZX DprecXY
              (DprecZY : precedes Z Y).

%worlds (ovar) (vbounded-increase _ _ _).
%total {} (vbounded-increase _ _ _).



vappend-vbounded : vappend H1 H2 H
		  -> vbounded H X
%%
		  -> vbounded H1 X 
		  -> type.
%mode vappend-vbounded +X1 +X2 -X3.

-	: vappend-vbounded vappend/nil D D.

-	: vappend-vbounded
	   (vappend/cons 
	      (Dvappend : vappend H1 H2 H))
	   (vbounded/cons
	      (Dvbounded : vbounded H Y)
	      (Dprecedes : precedes Y X))
	   Dvbounded''
	   <- vappend-vbounded Dvappend Dvbounded 
	      (Dvbounded' : vbounded H1 Y)
	   <- vbounded-increase Dvbounded' Dprecedes 
	      (Dvbounded'' : vbounded H1 X).

%worlds (ovar) (vappend-vbounded _ _ _).
%total D (vappend-vbounded D _ _).



extend-stack : vordered H
%%
		  -> ({x} isvar x I -> vbounded H x)
		  -> type.
%mode extend-stack +X1 -X2.

-       : extend-stack vordered/nil ([x] [d:isvar x 0] vbounded/nil d).

-       : extend-stack
           (vordered/cons (Dvbounded : vbounded H Y))
           ([x] [d:isvar x (s J)] vbounded/cons Dvbounded (precedes/i Dlt d Disvar))
           <- vbounded-isvar Dvbounded
              (Disvar : isvar Y J)
           <- lt-succ J (Dlt : lt J (s J)).

%worlds (ovar) (extend-stack _ _).
%total {} (extend-stack _ _).



vordered-car : vordered (vcons H X V) 
%%
	       -> isvar X I
	       -> type.
%mode vordered-car +X1 -X2.

-	: vordered-car 
	   (vordered/cons 
	      (Dvbounded : vbounded H X))
	   Disvar
	   <- vbounded-isvar Dvbounded (Disvar : isvar X I).

%worlds (ovar) (vordered-car _ _).
%total {} (vordered-car _ _).



vordered-cdr : vordered (vcons H X V) 
%%
	       -> vordered H 
	       -> type.
%mode vordered-cdr +X1 -X2.

-	: vordered-cdr 
	   (vordered/cons 
	      (Dvbounded : vbounded H X)) 
	   Dvordered
	   <- vbounded-is-vordered Dvbounded 
	      (Dvordered : vordered H).

%worlds (ovar) (vordered-cdr _ _).
%total {} (vordered-cdr _ _).



vlookup-vordered : vlookup H X A
		  -> vordered H
		  -> isvar X I 
		  -> type.
%mode vlookup-vordered +X1 +X2 -X3.

-	: vlookup-vordered 
	   vlookup/hit 
	   (Dvordered : vordered (vcons H X T))
	   Disvar
	   <- vordered-car Dvordered (Disvar : isvar X I).

-	: vlookup-vordered 
	   (vlookup/miss 
	      (Dvlookup : vlookup H X A))
	   (Dvordered : vordered (vcons H Y B))
	   Disvar
	   <- vordered-cdr Dvordered (Dvordered' : vordered H)
	   <- vlookup-vordered Dvlookup Dvordered' (Disvar : isvar X I).

%worlds (ovar) (vlookup-vordered _ _ _).
%total D (vlookup-vordered D _ _).



vbounded-contra : vbounded (vcons H X V) X 
%%
		  -> false
		  -> type.
%mode vbounded-contra +X1 -X2.

-	: vbounded-contra 
	   (vbounded/cons _ (Dprecedes : precedes X X))
	   Dfalse
	   <- precedes-irreflex Dprecedes Dfalse.

%worlds (ovar) (vbounded-contra _ _).
%total {} (vbounded-contra _ _).



vlookup-vbounded-contra : vlookup H X A
			 -> vbounded H X
%%
			 -> false 
			 -> type.
%mode vlookup-vbounded-contra +X1 +X2 -X3.

-       : vlookup-vbounded-contra 
	   vlookup/hit
	   (Dvbounded : vbounded (vcons H X V) X)
	   Dfalse
           <- vbounded-contra Dvbounded Dfalse.

-       : vlookup-vbounded-contra 
	   (vlookup/miss 
	      (Dvlookup : vlookup H X A))
	   (vbounded/cons
	      (Dvbounded : vbounded H Y)
	      (Dprecedes : precedes Y X))
	   Dfalse
           <- vbounded-increase Dvbounded Dprecedes (Dvbounded' : vbounded H X)
           <- vlookup-vbounded-contra Dvlookup Dvbounded' Dfalse.

%worlds (ovar) (vlookup-vbounded-contra _ _ _).
%total D (vlookup-vbounded-contra D _ _).



vappend-vlookup-eq : ({x} vappend (vcons H1 x V) (H2 x) (H x))
		    -> ({x} isvar x I -> vordered (H x))
		    -> ({x} vlookup (H x) x (B x))
%%
		    -> ({x} val-eq V (B x)) 
		    -> type.
%mode vappend-vlookup-eq +X1 +X2 +X3 -X4.

-       : vappend-vlookup-eq _ _ ([x] vlookup/hit) ([_] val-eq/i).

-       : vappend-vlookup-eq 
	   ([x] 
	      vappend/cons 
	      (Dvappend x : vappend (vcons H1 x A) (H2 x) (H x)))
	   ([x] [d:isvar x I] 
	      Dvordered x d : vordered (vcons (H x) (Y x) (C x)))
	   ([x] 
	      vlookup/miss (Dvlookup x : vlookup (H x) x (B x)))
           Deq
	   <- ({x} {d:isvar x I}
		 vordered-cdr (Dvordered x d) (Dvordered' x d : vordered (H x)))
           <- vappend-vlookup-eq Dvappend Dvordered' Dvlookup (Deq : {x} val-eq A (B x)).

-       : vappend-vlookup-eq 
	   ([x] vappend/nil) 
	   ([x] [d:isvar x I]
	      vordered/cons (Dvbounded x d : vbounded H1 x))
	   ([x] 
	      vlookup/miss (Dvlookup x : vlookup H1 x (B x)))
           Deq
           <- ({x} {d:isvar x I}
                 vlookup-vbounded-contra (Dvlookup x) (Dvbounded x d) Dfalse)
           <- ({x} false-implies-val-eq Dfalse (Deq x)).

-	: vappend-vlookup-eq 
	   ([x] 
	      vappend/cons 
	      (Dvappend x : vappend (vcons H1 x A) (H2 x) (H x)))
	   ([x] [d:isvar x I]
	      vordered/cons (Dvbounded x d : vbounded (H x) x))
	   ([x] vlookup/hit)
	   Deq
	   <- ({x} {d:isvar x I}
		 vappend-vbounded (Dvappend x) (Dvbounded x d) 
		 (Dvbounded' x d : vbounded (vcons H1 x A) x))
	   <- ({x} {d:isvar x I}
		 vbounded-contra (Dvbounded' x d) Dfalse)
	   <- ({x} false-implies-val-eq Dfalse (Deq x)).

%worlds (ovar) (vappend-vlookup-eq _ _ _ _).
%total D (vappend-vlookup-eq D _ _ _).



%% Vlookup is preserved under deletion of other variables.
vlookup-pdv : ({x} vappend (vcons H1 x A) (H2 x) (H x))
               -> vappend H1 (H2 M) H'
               -> ({x} vlookup (H x) Y (B x))
%%
               -> vlookup H' Y (B M) 
	       -> type.
%mode vlookup-pdv +X1 +X2 +X3 -X4.

-       : vlookup-pdv 
	   ([x] vappend/cons 
	      (Dvappend x : vappend (vcons H1 x A) (H2 x) (H x)))
	   (vappend/cons 
	      (Dvappend' : vappend H1 (H2 M) H'))
	   ([x] vlookup/hit)
	   %%
           vlookup/hit.

-       : vlookup-pdv
	   ([x] vappend/cons 
	      (Dvappend x : vappend (vcons H1 x A) (H2 x) (H x)))
	   (vappend/cons 
	      (Dvappend' : vappend H1 (H2 M) H'))
	   ([x] 
	      vlookup/miss 
	      (Dvlookup x : vlookup (H x) Y (B x)))
	   %%
           (vlookup/miss Dvlookup')
           <- vlookup-pdv Dvappend Dvappend' Dvlookup Dvlookup'.

-       : vlookup-pdv 
	   ([x] vappend/nil) 
	   vappend/nil 
	   ([x] vlookup/miss 
	      (Dvlookup x : vlookup _ _ (B x)))
	   %%
           (Dvlookup M).

%worlds (ovar) (vlookup-pdv _ _ _ _).
%total D (vlookup-pdv D _ _ _).



%%%%%  Evaluation Rules (Explicit Stack)  %%%%%

ev      : vctx -> exp -> val -> type.
evapp   : val -> val -> (exp -> val) -> type.

evapp/clo : evapp (clo H M) V' V
             <- {x} ev (vcons H x V') (M x) (V x).

evapp/bin : evapp (bin VM) VN ([x] (bin (V x)))
             <- {x} evapp (VM x) VN (V x).

ev/b    : ev H b v.

ev/var  : ev H X V
     <- vlookup H X V.

ev/lam  : ev H (lam D A ([x] M x)) (clo H M).

ev/app  : ev H (app M N) (bin ([x] V x))
     <- ev H M VM
     <- ev H N VN
     <- evapp VM VN ([x] V x).


%query 1 1 ev vnil b V.
%query 1 1 ev vnil (app (lam dnil o ([x] x)) b) V.
%query 1 1 ev vnil (lam dnil o ([x] (lam dnil o ([y] y)))) V.
%query 1 1 ev vnil (app (lam dnil o ([x] (lam dnil o ([y] y)))) b) V.
%query 1 1 ev vnil (app (lam dnil o ([x] (lam dnil o ([y] x)))) b) V.
%query 1 1 ev vnil (app (lam dnil (arrow dnil o o) ([x] (lam dnil o ([y] x)))) (lam dnil o ([x] x))) V.
%query 1 1 ev vnil (app (lam dnil (arrow dnil o o) ([x] (lam dnil o ([y] y)))) (app (lam dnil o ([x] (lam dnil o ([y] x)))) b)) V.
%query 0 * ev vnil (app b b) V.
%query 1 1 ev vnil (app (app (lam dnil o ([x] (lam dnil o ([y] y)))) b) b) V.
%query 1 1 ev vnil (app (app (app (lam dnil o ([x] (lam dnil o ([y] (lam dnil o [z] y))))) b) b) b) V.

%%%%%  Value Typing (Explicit Context & Stack)  %%%%%

wfv      : val -> ctx -> tp -> type.
wfe      : vctx -> ctx -> type.

wfv/v    : wfv v G o.

wfv/arrow : wfv (clo H M) G (arrow D A B)
      <- wfe H G'
      <- ({x}{d:isvar x I} of (cons G' x A) (M x) B)
      <- ({x}{d:isvar x I} ordered (cons G' x A))
      <- sub G' (arrow D A B) G (arrow D A B).

wfv/bin  : wfv (bin V) G A
            <- wft G A
            <- {x}{d:isvar x I} wfv (V x) G A.

wfv/sub  : wfv V G A
      <- wfv V G' A'
      <- sub G' A' G A.

wfe/nil  : wfe vnil nil.

wfe/cons : wfe (vcons H X V) (cons G X A)
      <- wfv V G A
      <- wfe H G.

1exp = (app (lam dnil o ([x] (lam dnil o ([y] x)))) b).
1tp = (arrow dnil o o).
%query 1 1 of nil 1exp 1tp.
%define 1clo = V
%solve  1ev : ev vnil 1exp V.
%query 1 1 wfv 1clo nil 1tp.
%query 1 1 wfv 1clo nil top.

false-implies-wfv : false -> wfv V G A -> type.
%mode +{V:val} +{G:ctx} +{A:tp} +{X1:false} -{X2:wfv V G A} (false-implies-wfv X1 X2).
%worlds (var | ovar) (false-implies-wfv _ _).
%total {} (false-implies-wfv _ _).

%%%%%  Safety  %%%%%

sub-ctx-trans : sub-ctx G1 G2
                 -> sub-ctx G2 G3
%%
                 -> sub-ctx G1 G3
       -> type.
%mode sub-ctx-trans +X1 +X2 -X3.

-/nil  : sub-ctx-trans S sub-ctx/nil S.
-/cons : sub-ctx-trans S12 (sub-ctx/cons OG3 S23) (sub-ctx/cons OG3 S13)
    <- sub-ctx-trans S12 S23 S13.

%worlds (var | ovar) (sub-ctx-trans _ _ _).
%total S23 (sub-ctx-trans _ S23 _).

minmax-ctx   : ctx -> ctx -> ctx -> ctx -> type.
minmax-ctx/1 : minmax-ctx G1 G2 G1 G2 <- sub-ctx G1 G2.
minmax-ctx/2 : minmax-ctx G1 G2 G2 G1 <- sub-ctx G2 G1.

sub-ctx-dia  : sub-ctx G1 G
                -> sub-ctx G2 G
%%
                -> minmax-ctx G1 G2 GS GU
   -> type.
%mode sub-ctx-dia +X1 +X2 -X3.

-  : sub-ctx-dia sub-ctx/nil S (minmax-ctx/2 S).
-  : sub-ctx-dia (sub-ctx/cons OG S1) sub-ctx/nil (minmax-ctx/1 (sub-ctx/cons OG S1)).
-  : sub-ctx-dia (sub-ctx/cons _ S1) (sub-ctx/cons _ S2) MM
<- sub-ctx-dia S1 S2 MM.

%worlds (var | ovar) (sub-ctx-dia _ _ _).
%total S (sub-ctx-dia S _ _).

bounded-to-vbounded : wfe H G -> bounded G X -> vbounded H X -> type.
%mode bounded-to-vbounded +X1 +X2 -X3.

bounded2v/nil  : bounded-to-vbounded wfe/nil (bounded/nil D) (vbounded/nil D).

bounded2v/cons : bounded-to-vbounded (wfe/cons WE WV) (bounded/cons BG P) (vbounded/cons HG P)
            <- bounded-to-vbounded WE BG HG.

%worlds (ovar) (bounded-to-vbounded _ _ _).
%total A (bounded-to-vbounded A _ _).

ordered-to-vordered : wfe H G -> ordered G -> vordered H -> type.
%mode ordered-to-vordered +X1 +X2 -X3.

ordered2v/nil  : ordered-to-vordered wfe/nil ordered/nil vordered/nil.

ordered2v/cons : ordered-to-vordered (wfe/cons WE WV) (ordered/cons GB) (vordered/cons HB)
            <- bounded-to-vbounded WE GB HB.

%worlds (ovar) (ordered-to-vordered _ _ _).
%total {} (ordered-to-vordered _ _ _).

extend-env : wfe H G
              -> ordered G
%%
		  -> ({x} isvar x I -> bounded G x)
		  -> ({x} isvar x I -> vbounded H x)
		  -> type.
%mode extend-env +X1 +X2 -X3 -X4.

-       : extend-env wfe/nil ordered/nil ([x] [d:isvar x 0] bounded/nil d) ([x] [d:isvar x 0] vbounded/nil d).

-       : extend-env
           (wfe/cons WE WV)
           (ordered/cons Dbounded)
           ([x] [d:isvar x (s J)] bounded/cons Dbounded (precedes/i Dlt d Disvar))
           ([x] [d:isvar x (s J)] vbounded/cons Dvbounded (precedes/i Dlt d Disvar))
           <- bounded-to-vbounded WE Dbounded Dvbounded
           <- bounded-isvar Dbounded
              (Disvar : isvar Y J)
           <- lt-succ J (Dlt : lt J (s J)).

%worlds (ovar) (extend-env _ _ _ _).
%total {} (extend-env _ _ _ _).

sub-refl    : wft G A
%%
               -> sub G A G A
               -> type.
%mode sub-refl +X1 -X2.

sub-decls-refl : wf-decls G D
%%
                  -> sub-decls G D G D
                  -> type.
%mode sub-decls-refl +X1 -X2.

sub-refl/o     : sub-refl wft/o sub/o.

sub-refl/top   : sub-refl wft/top (sub/top wft/top).

sub-refl/bot   : sub-refl wft/bot (sub/bot wft/bot).

sub-refl/arrow : sub-refl (wft/arrow WS WU D) (sub/arrow BS BU BD)
            <- sub-decls-refl D BD
            <- sub-refl WS BS
            <- sub-refl WU BU.

sub-refl/tsel  : sub-refl
                  (wft/tsel (pev/a OG L OD LD WU WS B))
                  (sub/tselx
                     (sub-decls/cons-hit
                        dbounded/nil dbounded/nil (sub-decls/nil wf-decls/nil)
                        BU BS B B)
                     (sub-decls/cons-hit
                        dbounded/nil dbounded/nil (sub-decls/nil wf-decls/nil)
                        BU BS B B)
                     (pev/a OG L OD LD WU WS B)
                     sub-ctx/nil
                     sub-ctx/nil)
            <- sub-refl WU BU
            <- sub-refl WS BS.

sub-refl/and  : sub-refl
                 (wft/and WR WL)
                 (sub/and2 (sub/and1r BR WL) (sub/and1l BL WR))
            <- sub-refl WR BR
            <- sub-refl WL BL.

sub-refl/or   : sub-refl
                 (wft/or WR WL)
                 (sub/or1 (sub/or2r BR WL) (sub/or2l BL WR))
            <- sub-refl WR BR
            <- sub-refl WL BL.


sub-decls-refl/nil : sub-decls-refl
                      wf-decls/nil
                      (sub-decls/nil wf-decls/nil).

sub-decls-refl/cons : sub-decls-refl
                       (wf-decls/cons OD WD B WU WS)
                       (sub-decls/cons-hit
                          OD OD BD BU BS B B)
                 <- sub-refl WU BU
                 <- sub-refl WS BS
                 <- sub-decls-refl WD BD.

%worlds (var | ovar) (sub-refl _ _) (sub-decls-refl _ _).
%total (W WD) (sub-refl W _) (sub-decls-refl WD _).

extend-wft  : wft G B
               -> ordered (cons G X A)
%%
               -> wft (cons G X A) B
-> type.
%mode extend-wft +X1 +X2 -X3.

extend-wf-decls  : wf-decls G D
                    -> ordered (cons G X A)
%%
                    -> wf-decls (cons G X A) D
-> type.
%mode extend-wf-decls +X1 +X2 -X3.

extend-pev   : pev G Y L AS AU
                -> ordered (cons G X A)
%%
                -> pev (cons G X A) Y L AS AU
-> type.
%mode extend-pev +X1 +X2 -X3.

extend-expand: expand G B D
                -> ordered (cons G X A)
%%
                -> expand (cons G X A) B D
-> type.
%mode extend-expand +X1 +X2 -X3.

extend-sub2  : sub G1 A1 G2 A2
                -> ordered (cons G2 X A)
%%
                -> sub G1 A1 (cons G2 X A) A2
         -> type.
%mode extend-sub2 +X1 +X2 -X3.

extend-sub1  : sub G1 A1 G2 A2
                -> ordered (cons G1 X A)
%%
                -> sub (cons G1 X A) A1 G2 A2
         -> type.
%mode extend-sub1 +X1 +X2 -X3.

extend-sub   : sub G1 A1 G2 A2
                -> ordered (cons G1 X A)
                -> ordered (cons G2 X A)
%%
                -> sub (cons G1 X A) A1 (cons G2 X A) A2
         -> type.
%mode extend-sub +X1 +X2 +X3 -X4.

extend-sub-decls2  : sub-decls G1 D1 G2 D2
                -> ordered (cons G2 X A)
%%
                -> sub-decls G1 D1 (cons G2 X A) D2
         -> type.
%mode extend-sub-decls2 +X1 +X2 -X3.

extend-sub-decls1  : sub-decls G1 D1 G2 D2
                -> ordered (cons G1 X A)
%%
                -> sub-decls (cons G1 X A) D1 G2 D2
         -> type.
%mode extend-sub-decls1 +X1 +X2 -X3.

extend-sub-decls   : sub-decls G1 D1 G2 D2
                -> ordered (cons G1 X A)
                -> ordered (cons G2 X A)
%%
                -> sub-decls (cons G1 X A) D1 (cons G2 X A) D2
         -> type.
%mode extend-sub-decls +X1 +X2 +X3 -X4.

-/o2     : extend-sub2 sub/o _ sub/o.

-/o1     : extend-sub1 sub/o _ sub/o.

-/o      : extend-sub  sub/o _ _ sub/o.

-/top2   : extend-sub2 (sub/top W) OG (sub/top W).

-/top1   : extend-sub1 (sub/top W) OG (sub/top W')
      <- extend-wft W OG W'.

-/top    : extend-sub  (sub/top W) OG1 OG2 (sub/top W')
      <- extend-wft W OG1 W'.

-/bot2   : extend-sub2 (sub/bot W) OG (sub/bot W')
      <- extend-wft W OG W'.

-/bot1   : extend-sub1 (sub/bot W) OG (sub/bot W).

-/bot    : extend-sub  (sub/bot W) OG1 OG2 (sub/bot W')
      <- extend-wft W OG2 W'.

-/arrow2 : extend-sub2 (sub/arrow BU BS D) OG (sub/arrow BU' BS' D')
      <- extend-sub-decls2 D OG D'
      <- extend-sub1 BS OG BS'
      <- extend-sub2 BU OG BU'.

-/arrow1 : extend-sub1 (sub/arrow BU BS D) OG (sub/arrow BU' BS' D')
      <- extend-sub-decls1 D OG D'
      <- extend-sub2 BS OG BS'
      <- extend-sub1 BU OG BU'.

-/arrow  : extend-sub  (sub/arrow BU BS D) OG1 OG2 (sub/arrow BU' BS' D')
      <- extend-sub-decls D OG1 OG2 D'
      <- extend-sub BS OG2 OG1 BS'
      <- extend-sub BU OG1 OG2 BU'.

-/tsel12 : extend-sub2 (sub/tsel1 P S) OG (sub/tsel1 P S')
      <- extend-sub2 S OG S'.

-/tsel21 : extend-sub1 (sub/tsel2 P S) OG (sub/tsel2 P S')
      <- extend-sub1 S OG S'.

-/tsel22 : extend-sub2
            (sub/tsel2 (pev/a _  L EX LD WU WS B) S) OG
            (sub/tsel2 (pev/a OG (lookup/miss L) EX' LD WU' WS' B') S')
      <- extend-sub B OG OG B'
      <- extend-wft WU OG WU'
      <- extend-wft WS OG WS'
      <- extend-sub2 S OG S'
      <- extend-expand EX OG EX'.

-/tsel11 : extend-sub1
            (sub/tsel1 (pev/a _  L EX LD WU WS B) S) OG
            (sub/tsel1 (pev/a OG (lookup/miss L) EX' LD WU' WS' B') S')
      <- extend-sub B OG OG B'
      <- extend-wft WU OG WU'
      <- extend-wft WS OG WS'
      <- extend-sub1 S OG S'
      <- extend-expand EX OG EX'.

-/tsel2  : extend-sub
            (sub/tsel2 P  S ) OG1 OG2
            (sub/tsel2 P' S')
      <- extend-pev P OG2 P'
      <- extend-sub S OG1 OG2 S'.

-/tsel1  : extend-sub
            (sub/tsel1 P  S ) OG1 OG2
            (sub/tsel1 P' S')
      <- extend-pev P OG1 P'
      <- extend-sub S OG1 OG2 S'.

-/tselx2 : extend-sub2
            (sub/tselx BD12  BD21  P S1 S2) OG
            (sub/tselx BD12' BD21' P S1 (sub-ctx/cons OG S2))
      <- extend-sub-decls2 BD12 OG BD12'
      <- extend-sub-decls1 BD21 OG BD21'.

-/tselx1 : extend-sub1
            (sub/tselx BD12  BD21  P S1 S2) OG
            (sub/tselx BD12' BD21' P (sub-ctx/cons OG S1) S2)
      <- extend-sub-decls1 BD12 OG BD12'
      <- extend-sub-decls2 BD21 OG BD21'.

-/tselx  : extend-sub
            (sub/tselx BD12  BD21  P S1 S2) OG1 OG2
            (sub/tselx BD12' BD21' P (sub-ctx/cons OG1 S1) (sub-ctx/cons OG2 S2))
      <- extend-sub-decls BD12 OG1 OG2 BD12'
      <- extend-sub-decls BD21 OG2 OG1 BD21'.

-/and1l2 : extend-sub2
            (sub/and1l BL WR)
            OG
            (sub/and1l BL' WR)
      <- extend-sub2 BL OG BL'.

-/and1r2 : extend-sub2
            (sub/and1r BR WL)
            OG
            (sub/and1r BR' WL)
      <- extend-sub2 BR OG BR'.

-/and22  : extend-sub2
            (sub/and2 BR BL)
            OG
            (sub/and2 BR' BL')
      <- extend-sub2 BR OG BR'
      <- extend-sub2 BL OG BL'.

-/or2l2 : extend-sub2
            (sub/or2l BL WR)
            OG
            (sub/or2l BL' WR')
      <- extend-sub2 BL OG BL'
      <- extend-wft WR OG WR'.

-/or2r2 : extend-sub2
            (sub/or2r BR WL)
            OG
            (sub/or2r BR' WL')
      <- extend-sub2 BR OG BR'
      <- extend-wft WL OG WL'.

-/or12  : extend-sub2
            (sub/or1 BR BL)
            OG
            (sub/or1 BR' BL')
      <- extend-sub2 BR OG BR'
      <- extend-sub2 BL OG BL'.

-/and1l1 : extend-sub1
            (sub/and1l BL WR)
            OG
            (sub/and1l BL' WR')
      <- extend-sub1 BL OG BL'
      <- extend-wft WR OG WR'.

-/and1r1 : extend-sub1
            (sub/and1r BR WL)
            OG
            (sub/and1r BR' WL')
      <- extend-sub1 BR OG BR'
      <- extend-wft WL OG WL'.

-/and21  : extend-sub1
            (sub/and2 BR BL)
            OG
            (sub/and2 BR' BL')
      <- extend-sub1 BR OG BR'
      <- extend-sub1 BL OG BL'.

-/or2l1 : extend-sub1
            (sub/or2l BL WR)
            OG
            (sub/or2l BL' WR)
      <- extend-sub1 BL OG BL'.

-/or2r1 : extend-sub1
            (sub/or2r BR WL)
            OG
            (sub/or2r BR' WL)
      <- extend-sub1 BR OG BR'.

-/or11  : extend-sub1
            (sub/or1 BR BL)
            OG
            (sub/or1 BR' BL')
      <- extend-sub1 BR OG BR'
      <- extend-sub1 BL OG BL'.

-/and1l  : extend-sub
            (sub/and1l BL WR)
            OG1 OG2
            (sub/and1l BL' WR')
      <- extend-sub BL OG1 OG2 BL'
      <- extend-wft WR OG1 WR'.

-/and1r  : extend-sub
            (sub/and1r BR WL)
            OG1 OG2
            (sub/and1r BR' WL')
      <- extend-sub BR OG1 OG2 BR'
      <- extend-wft WL OG1 WL'.

-/and2   : extend-sub
            (sub/and2 BR BL)
            OG1 OG2
            (sub/and2 BR' BL')
      <- extend-sub BR OG1 OG2 BR'
      <- extend-sub BL OG1 OG2 BL'.

-/or2l  : extend-sub
            (sub/or2l BL WR)
            OG1 OG2
            (sub/or2l BL' WR')
      <- extend-sub BL OG1 OG2 BL'
      <- extend-wft WR OG2 WR'.

-/or2r  : extend-sub
            (sub/or2r BR WL)
            OG1 OG2
            (sub/or2r BR' WL')
      <- extend-sub BR OG1 OG2 BR'
      <- extend-wft WL OG2 WL'.

-/or1   : extend-sub
            (sub/or1 BR BL)
            OG1 OG2
            (sub/or1 BR' BL')
      <- extend-sub BR OG1 OG2 BR'
      <- extend-sub BL OG1 OG2 BL'.

-  : extend-wft wft/o _ wft/o.

-  : extend-wft wft/top _ wft/top.

-  : extend-wft wft/bot _ wft/bot.

-  : extend-wft (wft/arrow WU WS D) OG (wft/arrow WU' WS' D')
<- extend-wf-decls D OG D'
<- extend-wft WS OG WS'
<- extend-wft WU OG WU'.

-  : extend-wft (wft/tsel P) OG (wft/tsel P')
<- extend-pev P OG P'.

-  : extend-wft (wft/and WR WL) OG (wft/and WR' WL')
<- extend-wft WL OG WL'
<- extend-wft WR OG WR'.


-  : extend-wft (wft/or WR WL) OG (wft/or WR' WL')
<- extend-wft WL OG WL'
<- extend-wft WR OG WR'.

-  : extend-pev (pev/a _ L EX LD WU WS B) OG (pev/a OG (lookup/miss L) EX' LD WU' WS' B')
<- extend-sub B OG OG B'
<- extend-wft WS OG WS'
<- extend-wft WU OG WU'
<- extend-expand EX OG EX'.

-  : extend-expand (expand/arrow OD) OG (expand/arrow OD).

-  : extend-sub-decls2 (sub-decls/nil OD) OG (sub-decls/nil OD).

-  : extend-sub-decls2
      (sub-decls/cons-hit DB2 DB1 BD BU BS B2 B1)
      OG
      (sub-decls/cons-hit DB2 DB1 BD' BU' BS' B2' B1)
<- extend-sub-decls2 BD OG BD'
<- extend-sub2 BU OG BU'
<- extend-sub1 BS OG BS'
<- extend-sub B2 OG OG B2'.

-  : extend-sub-decls2
      (sub-decls/cons-miss DB2 WD1 BD)
      OG
      (sub-decls/cons-miss DB2 WD1 BD')
<- extend-sub-decls2 BD OG BD'.

-  : extend-sub-decls1 (sub-decls/nil WD) OG (sub-decls/nil WD')
<- extend-wf-decls WD OG WD'.

-  : extend-sub-decls1
      (sub-decls/cons-hit DB2 DB1 BD BU BS B2 B1)
      OG
      (sub-decls/cons-hit DB2 DB1 BD' BU' BS' B2 B1')
<- extend-sub-decls1 BD OG BD'
<- extend-sub1 BU OG BU'
<- extend-sub2 BS OG BS'
<- extend-sub B1 OG OG B1'.

-  : extend-sub-decls1
      (sub-decls/cons-miss DB2 WD1 BD)
      OG
      (sub-decls/cons-miss DB2 WD1' BD')
<- extend-wf-decls WD1 OG WD1'
<- extend-sub-decls1 BD OG BD'.

-  : extend-sub-decls (sub-decls/nil WD) OG1 OG2 (sub-decls/nil WD')
<- extend-wf-decls WD OG1 WD'.

-  : extend-sub-decls
      (sub-decls/cons-hit DB2 DB1 BD BU BS B2 B1)
      OG1 OG2
      (sub-decls/cons-hit DB2 DB1 BD' BU' BS' B2' B1')
<- extend-sub-decls BD OG1 OG2 BD'
<- extend-sub BU OG1 OG2 BU'
<- extend-sub BS OG2 OG1 BS'
<- extend-sub B2 OG2 OG2 B2'
<- extend-sub B1 OG1 OG1 B1'.

-  : extend-sub-decls
      (sub-decls/cons-miss DB2 WD1 BD)
      OG1 OG2
      (sub-decls/cons-miss DB2 WD1' BD')
<- extend-wf-decls WD1 OG1 WD1'
<- extend-sub-decls BD OG1 OG2 BD'.

-  : extend-wf-decls wf-decls/nil OG wf-decls/nil.

-  : extend-wf-decls
      (wf-decls/cons DB WD B WU WS)
      OG
      (wf-decls/cons DB WD' B' WU' WS')
<- extend-wf-decls WD OG WD'
<- extend-sub B OG OG B'
<- extend-wft WU OG WU'
<- extend-wft WS OG WS'.

%worlds (var | ovar) (extend-sub2 _ _ _) (extend-sub1 _ _ _) (extend-sub _ _ _ _) (extend-sub-decls2 _ _ _) (extend-sub-decls1 _ _ _) (extend-sub-decls _ _ _ _) (extend-wft _ _ _) (extend-wf-decls _ _ _) (extend-pev _ _ _) (extend-expand _ _ _).
%total (S2 S1 S D2 D1 D W DW P EX) (extend-sub2 S2 _ _) (extend-sub1 S1 _ _) (extend-sub S _ _ _) (extend-sub-decls2 D2 _ _) (extend-sub-decls1 D1 _ _) (extend-sub-decls D _ _ _) (extend-wft W _ _) (extend-wf-decls DW _ _) (extend-pev P _ _) (extend-expand EX _ _).

extend-wft-sub-ctx : wft G1 A
                      -> sub-ctx G1 G2
%%
                      -> wft G2 A
  -> type.
%mode extend-wft-sub-ctx +X1 +X2 -X3.

- : extend-wft-sub-ctx W sub-ctx/nil W.

- : extend-wft-sub-ctx W (sub-ctx/cons OG S) W''
<- extend-wft-sub-ctx W S W'
<- extend-wft W' OG W''.

%worlds (var | ovar) (extend-wft-sub-ctx _ _ _).
%total S (extend-wft-sub-ctx _ S _).

extend-pev-sub-ctx : pev G1 X L AS AU
                      -> sub-ctx G1 G2
%%
                      -> pev G2 X L AS AU
  -> type.
%mode extend-pev-sub-ctx +X1 +X2 -X3.

- : extend-pev-sub-ctx P sub-ctx/nil P.

- : extend-pev-sub-ctx P (sub-ctx/cons OG S) P''
<- extend-pev-sub-ctx P S P'
<- extend-pev P' OG P''.

%worlds (var | ovar) (extend-pev-sub-ctx _ _ _).
%total S (extend-pev-sub-ctx _ S _).

extend-sub1-sub-ctx : sub G1 A1 G2 A2
                       -> sub-ctx G1 G1'
%%
                       -> sub G1' A1 G2 A2
   -> type.
%mode extend-sub1-sub-ctx +X1 +X2 -X3.

- : extend-sub1-sub-ctx B sub-ctx/nil B.

- : extend-sub1-sub-ctx B (sub-ctx/cons OG S) B''
<- extend-sub1-sub-ctx B S B'
<- extend-sub1 B' OG B''.

%worlds (var | ovar) (extend-sub1-sub-ctx _ _ _).
%total S (extend-sub1-sub-ctx _ S _).

extend-sub2-sub-ctx : sub G1 A1 G2 A2
                       -> sub-ctx G2 G2'
%%
                       -> sub G1 A1 G2' A2
   -> type.
%mode extend-sub2-sub-ctx +X1 +X2 -X3.

- : extend-sub2-sub-ctx B sub-ctx/nil B.

- : extend-sub2-sub-ctx B (sub-ctx/cons OG S) B''
<- extend-sub2-sub-ctx B S B'
<- extend-sub2 B' OG B''.

%worlds (var | ovar) (extend-sub2-sub-ctx _ _ _).
%total S (extend-sub2-sub-ctx _ S _).

extend-lookup-sub-ctx : lookup G1 X A
                         -> sub-ctx G1 G2
%%
                         -> lookup G2 X A
  -> type.
%mode extend-lookup-sub-ctx +X1 +X2 -X3.

- : extend-lookup-sub-ctx L sub-ctx/nil L.

- : extend-lookup-sub-ctx L (sub-ctx/cons OG S) (lookup/miss L')
<- extend-lookup-sub-ctx L S L'.

%worlds (var | ovar) (extend-lookup-sub-ctx _ _ _).
%total S (extend-lookup-sub-ctx _ S _).

ordered-sub-ctx1 : sub-ctx G1 G2
                   -> ordered G2
%%
                   -> ordered G1
  -> type.
%mode ordered-sub-ctx1 +X1 +X2 -X3.

- : ordered-sub-ctx1 sub-ctx/nil OG OG.

- : ordered-sub-ctx1 (sub-ctx/cons _ S) (ordered/cons BG) OG'
<- bounded-is-ordered BG OG
<- ordered-sub-ctx1 S OG OG'.

%worlds (ovar) (ordered-sub-ctx1 _ _ _).
%total S (ordered-sub-ctx1 S _ _).

ordered-sub-ctx2 : sub-ctx G1 G2
                   -> ordered G1
%%
                   -> ordered G2
  -> type.
%mode ordered-sub-ctx2 +X1 +X2 -X3.

- : ordered-sub-ctx2 sub-ctx/nil OG OG.

- : ordered-sub-ctx2 (sub-ctx/cons OG2 S) OG1 OG2.

%worlds (ovar) (ordered-sub-ctx2 _ _ _).
%total {} (ordered-sub-ctx2 _ _ _).

extract-wf    : sub G1 A1 G2 A2
%%
                 -> wft G1 A1
                 -> wft G2 A2
       -> type.
%mode extract-wf +X1 -X2 -X3.

extract-wf-decls: sub-decls G1 D1 G2 D2
%%
                 -> wf-decls G1 D1
                 -> wf-decls G2 D2
       -> type.
%mode extract-wf-decls +X1 -X2 -X3.

extract-wf-pev: pev G X L AS AU
%%
                 -> wft G AS
                 -> wft G AU
                 -> sub G AS G AU
       -> type.
%mode extract-wf-pev +X1 -X2 -X3 -X4.

-     : extract-wf-pev (pev/a OG L OD LD WU WS B) WS WU B.

-     : extract-wf sub/o wft/o wft/o.

-     : extract-wf (sub/top W) W wft/top.

-     : extract-wf (sub/bot W) wft/bot W.

-     : extract-wf (sub/arrow BU BS BD) (wft/arrow WU1 WS1 WD1) (wft/arrow WU2 WS2 WD2)
   <- extract-wf-decls BD WD1 WD2
   <- extract-wf BU WU1 WU2
   <- extract-wf BS WS2 WS1.

-     : extract-wf
         (sub/tsel1 P B)
         (wft/tsel P)
         W2
   <- extract-wf B _ W2.

-     : extract-wf
         (sub/tsel2 P B)
         W1
         (wft/tsel P)
   <- extract-wf B W1 _.

-     : extract-wf
         (sub/tselx B12 B21 P S1 S2)
         (wft/tsel P1)
         (wft/tsel P2)
   <- extend-pev-sub-ctx P S1 P1
   <- extend-pev-sub-ctx P S2 P2.

-     : extract-wf-decls
         (sub-decls/nil WD1)
         WD1
         wf-decls/nil.

-     : extract-wf-decls
         (sub-decls/cons-hit OD2 OD1 BD BU BS B2 B1)
         (wf-decls/cons OD1 WD1 B1 WU1 WS1)
         (wf-decls/cons OD2 WD2 B2 WU2 WS2)
<- extract-wf B2 WS2 WU2
<- extract-wf B1 WS1 WU1
<- extract-wf-decls BD WD1 WD2.


-     : extract-wf-decls
         (sub-decls/cons-miss _ WD1 BD)
         WD1
         WD2
<- extract-wf-decls BD _ WD2.

%worlds (ovar) (extract-wf _ _ _) (extract-wf-decls _ _ _) (extract-wf-pev _ _ _ _).
%total (B D P) (extract-wf B _ _) (extract-wf-decls D _ _) (extract-wf-pev P _ _ _).

extract-wf-pev-low : pev G X L AS AU
%%
                      -> wft G AS
                      -> type.
%mode extract-wf-pev-low +X1 -X2.
-    : extract-wf-pev-low (pev/a OG L OD LD WU WS B) WS.
%worlds (var | ovar) (extract-wf-pev-low _ _).
%reduces W < P (extract-wf-pev-low P W).
%total P (extract-wf-pev-low P _).

extract-wf-pev-high : pev G X L AS AU
%%
                      -> wft G AU
                      -> type.
%mode extract-wf-pev-high +X1 -X2.
-    : extract-wf-pev-high (pev/a OG L OD LD WU WS B) WU.
%worlds (var | ovar) (extract-wf-pev-high _ _).
%reduces W < P (extract-wf-pev-high P W).
%total P (extract-wf-pev-high P _).

extract-wf-tp : of G M A
%%
                 -> wft G A
     -> type.
%mode extract-wf-tp +X1 -X2.

-    : extract-wf-tp of/b wft/o.

-    : extract-wf-tp (of/var D W OG L) W.

-    : extract-wf-tp (of/lam WD _ _) WD.

-    : extract-wf-tp (of/app TM TN) W2
  <- extract-wf-tp TM (wft/arrow W2 W1 D).

-    : extract-wf-tp (of/sub B T) W2
  <- extract-wf B W1 W2.

%worlds (ovar) (extract-wf-tp _ _).
%total W (extract-wf-tp W _).

wft-min       : wft G1 A
                 -> wft G2 A
                 -> minmax-ctx G1 G2 GS GU
%%
                 -> wft GS A
                 -> sub-ctx GS G1
                 -> sub-ctx GS G2
   -> type.
%mode wft-min +X1 +X2 +X3 -X4 -X5 -X6.

-  : wft-min W1 W2 (minmax-ctx/1 S12) W1 sub-ctx/nil S12.
-  : wft-min W1 W2 (minmax-ctx/2 S21) W2 S21 sub-ctx/nil.

%worlds (var | ovar) (wft-min _ _ _ _ _ _).
%total M (wft-min _ _ M _ _ _).

wft-dia       : wft G A
                 -> wft G1 A
                 -> wft G2 A
                 -> sub-ctx G1 G
                 -> sub-ctx G2 G
%%
                 -> wft G' A
                 -> sub-ctx G' G1
                 -> sub-ctx G' G2
   -> type.
%mode wft-dia +X1 +X2 +X3 +X4 +X5 -X6 -X7 -X8.

-  : wft-dia W W1 W2 S1 S2 W' S1' S2'
<- sub-ctx-dia S1 S2 MM
<- wft-min W1 W2 MM W' S1' S2'.

%worlds (var | ovar) (wft-dia _ _ _ _ _ _ _ _).
%total W   (wft-dia W _ _ _ _ _ _ _).

pev-min       : pev G1 X L AS AU
                 -> pev G2 X L AS AU
                 -> minmax-ctx G1 G2 GS GU
%%
                 -> pev GS X L AS AU
                 -> sub-ctx GS G1
                 -> sub-ctx GS G2
   -> type.
%mode pev-min +X1 +X2 +X3 -X4 -X5 -X6.

-  : pev-min P1 P2 (minmax-ctx/1 S12) P1 sub-ctx/nil S12.
-  : pev-min P1 P2 (minmax-ctx/2 S21) P2 S21 sub-ctx/nil.

%worlds (var | ovar) (pev-min _ _ _ _ _ _).
%total M (pev-min _ _ M _ _ _).

pev-dia       : pev G X L AS AU
                 -> pev G1 X L AS AU
                 -> pev G2 X L AS AU
                 -> sub-ctx G1 G
                 -> sub-ctx G2 G
%%
                 -> pev G' X L AS AU
                 -> sub-ctx G' G1
                 -> sub-ctx G' G2
   -> type.
%mode pev-dia +X1 +X2 +X3 +X4 +X5 -X6 -X7 -X8.

-  : pev-dia P P1 P2 S1 S2 P' S1' S2'
<- sub-ctx-dia S1 S2 MM
<- pev-min P1 P2 MM P' S1' S2'.

%worlds (var | ovar) (pev-dia _ _ _ _ _ _ _ _).
%total P (pev-dia P _ _ _ _ _ _ _).

lookup-eq     : lookup G M A
                 -> lookup G M' A'
                 -> exp-eq M M'
                 -> ordered G
%%
                 -> tp-eq A A'
      -> type.
%mode lookup-eq +X1 +X2 +X3 +X4 -X5.

-     : lookup-eq lookup/hit lookup/hit EQ OG tp-eq/i.

-     : lookup-eq (lookup/miss L) (lookup/miss L') EQ (ordered/cons BG) EQ'
   <- bounded-is-ordered BG OG
   <- lookup-eq L L' EQ OG EQ'.

-     : lookup-eq (lookup/hit: lookup _ _ A) ((lookup/miss L'): lookup _ _ A') EQ (ordered/cons BG) EQ'
   <- lookup-eq-bounded-contra L' BG EQ CONTRA
   <- false-implies-tp-eq CONTRA (EQ': tp-eq A A').

-     : lookup-eq ((lookup/miss L): lookup _ _ A) (lookup/hit: lookup _ _ A') EQ (ordered/cons BG) EQ'
   <- lookup-eq-bounded-contra L BG EQ CONTRA
   <- false-implies-tp-eq CONTRA (EQ': tp-eq A A').

%worlds (ovar) (lookup-eq _ _ _ _ _).
%total L (lookup-eq L _ _ _ _).

arrow-eq       : tp-eq (arrow D AS AU) (arrow D' AS' AU')
%%
                  -> decls-eq D D'
                  -> tp-eq AS AS'
                  -> tp-eq AU AU'
                  -> type.
%mode arrow-eq +X1 -X2 -X3 -X4.

arrow-eq/i : arrow-eq tp-eq/i decls-eq/i tp-eq/i tp-eq/i.

%worlds (var | ovar) (arrow-eq _ _ _ _).
%total EQ (arrow-eq EQ _ _ _).

label-less-trans : label-less LX LY -> label-less LY LZ -> label-less LX LZ -> type.
%mode label-less-trans +X1 +X2 -X3.

-  : label-less-trans
      (label-less/nat LTXY)
      (label-less/nat LTYZ)
      (label-less/nat LTXZ)
<- lt-trans LTXY LTYZ LTXZ.

%worlds (var | ovar) (label-less-trans _ _ _).
%total {} (label-less-trans _ _ _).

dbounded-is-dordered : dbounded D L
%%
		      -> dordered D
		      -> type.
%mode dbounded-is-dordered +X1 -X2.

-       : dbounded-is-dordered dbounded/nil dordered/nil.

-       : dbounded-is-dordered (dbounded/cons D _) (dordered/cons D).

%worlds (var | ovar) (dbounded-is-dordered _ _).
%total {} (dbounded-is-dordered _ _).

label-less-eq-irreflex : label-less LX LY -> label-eq LX LY -> false -> type.
%mode label-less-eq-irreflex +X1 +X2 -X3.

-       : label-less-eq-irreflex 
           (label-less/nat Dlt) 
           DEeq
           Dfalse
           <- lt-resp nat-eq/i nat-eq/i Dlt Dlt'
           <- lt-antisymm Dlt' Dfalse.

%worlds (var | ovar) (label-less-eq-irreflex _ _ _).
%total {} (label-less-eq-irreflex _ _ _).

dbounded-eq-contra : dbounded (dcons D LX AS AU) LY
                     -> label-eq LX LY
%%
		  -> false
		  -> type.
%mode dbounded-eq-contra +X1 +X2 -X3.

-	: dbounded-eq-contra 
	   (dbounded/cons _ (Dprecedes : label-less X Y))
     Deq
	   Dfalse
	   <- label-less-eq-irreflex Dprecedes Deq Dfalse.

%worlds (var | ovar) (dbounded-eq-contra _ _ _).
%total {} (dbounded-eq-contra _ _ _).

dbounded-increase : dbounded D LX
                    -> label-less LX LY
%%
                    -> dbounded D LY 
		    -> type.
%mode dbounded-increase +X1 +X2 -X3.

-       : dbounded-increase
           dbounded/nil
           (label-less/nat _)
           dbounded/nil.

-       : dbounded-increase
           (dbounded/cons 
              (Dbounded : dbounded D LZ)
              (DprecZX : label-less LZ LX))
           (DprecXY : label-less LX LY)
           (dbounded/cons Dbounded DprecZY)
           <- label-less-trans DprecZX DprecXY
              (DprecZY : label-less LZ LY).

%worlds (var | ovar) (dbounded-increase _ _ _).
%total {} (dbounded-increase _ _ _).

dlookup-eq-bounded-contra : dlookup D LX AS AU
			 -> dbounded D LY
       -> label-eq LX LY
%%
			 -> false 
			 -> type.
%mode dlookup-eq-bounded-contra +X1 +X2 +X3 -X4.

-       : dlookup-eq-bounded-contra 
	   dlookup/hit
	   (Dbounded : dbounded (dcons D LX AS AU) LY)
     Deq
	   Dfalse
           <- dbounded-eq-contra Dbounded Deq Dfalse.

-       : dlookup-eq-bounded-contra 
	   (dlookup/miss 
	      (Dlookup : dlookup D LX AS AU))
	   (dbounded/cons
	      (Dbounded : dbounded D LY)
	      (Dprecedes : label-less LY LX))
     Deq
	   Dfalse
           <- dbounded-increase Dbounded Dprecedes (Dbounded' : dbounded D LX)
           <- dlookup-eq-bounded-contra Dlookup Dbounded' Deq Dfalse.

%worlds (var | ovar) (dlookup-eq-bounded-contra _ _ _ _).
%total D (dlookup-eq-bounded-contra D _ _ _).

dlookup-eq     : dlookup D L AS AU
                 -> dlookup D' L AS' AU'
                 -> decls-eq D D'
                 -> dordered D
                 -> dordered D'
%%
                 -> tp-eq AS AS'
                 -> tp-eq AU AU'
      -> type.
%mode dlookup-eq +X1 +X2 +X3 +X4 +X5 -X6 -X7.

- : dlookup-eq dlookup/hit dlookup/hit EQ OD OD' tp-eq/i tp-eq/i.

- : dlookup-eq (dlookup/miss DL) (dlookup/miss DL') EQ (dordered/cons BD) (dordered/cons BD') EQS EQU
<- dbounded-is-dordered BD OD
<- dbounded-is-dordered BD' OD'
<- dlookup-eq DL DL' decls-eq/i OD OD' EQS EQU.

- : dlookup-eq (dlookup/hit : dlookup _ _ AS AU) ((dlookup/miss L'): dlookup _ _ AS' AU') EQ (dordered/cons BD) _ EQS EQU
<- dlookup-eq-bounded-contra L' BD label-eq/i CONTRA
<- false-implies-tp-eq CONTRA (EQS: tp-eq AS AS')
<- false-implies-tp-eq CONTRA (EQU: tp-eq AU AU').

- : dlookup-eq ((dlookup/miss L): dlookup _ _ AS AU) (dlookup/hit : dlookup _ _ AS' AU')  EQ _ (dordered/cons BD') EQS EQU
<- dlookup-eq-bounded-contra L BD' label-eq/i CONTRA
<- false-implies-tp-eq CONTRA (EQS: tp-eq AS AS')
<- false-implies-tp-eq CONTRA (EQU: tp-eq AU AU').

%worlds (var | ovar) (dlookup-eq _ _ _ _ _ _ _).
%total DL (dlookup-eq DL _ _ _ _ _ _).

sub-eq2       : tp-eq A2 A2'
                 -> sub G1 A1 G2 A2
                 -> sub G1 A1 G2 A2'
       -> type.
%mode sub-eq2 +X1 +X2 -X3.

-      : sub-eq2 tp-eq/i B B.

%worlds (var | ovar) (sub-eq2 _ _ _).
%reduces B' <= B (sub-eq2 _ B B').
%total EQ (sub-eq2 EQ _ _).

sub-eq1       : tp-eq A1 A1'
                 -> sub G1 A1 G2 A2
                 -> sub G1 A1' G2 A2
       -> type.
%mode sub-eq1 +X1 +X2 -X3.

-      : sub-eq1 tp-eq/i B B.

%worlds (var | ovar) (sub-eq1 _ _ _).
%reduces B' <= B (sub-eq1 _ B B').
%total EQ (sub-eq1 EQ _ _).

wft-eq        : tp-eq A A'
                 -> wft G A
%%
                 -> wft G A'
  -> type.
%mode wft-eq +X1 +X2 -X3.

- : wft-eq tp-eq/i W W.

%worlds (var | ovar) (wft-eq _ _ _).
%reduces W' <= W (wft-eq _ W W').
%total EQ (wft-eq EQ _ _).

pev-eq        : tp-eq AS AS'
                 -> tp-eq AU AU'
                 -> pev G X L AS AU
%%
                 -> pev G X L AS' AU'
  -> type.
%mode pev-eq +X1 +X2 +X3 -X4.

- : pev-eq tp-eq/i tp-eq/i P P.

%worlds (var | ovar) (pev-eq _ _ _ _).
%reduces P' <= P (pev-eq _ _ P P').
%total EQ (pev-eq EQ _ _ _).

lookup-label-eq: lookup G M A
                  -> expand G A D
                  -> dlookup D L AS AU
                  -> lookup G M' A'
                  -> expand G A' D'
                  -> dlookup D' L' AS' AU'
                  -> exp-eq M M'
                  -> label-eq L L'
                  -> ordered G
%%
                 -> tp-eq AS AS'
                 -> tp-eq AU AU'
      -> type.
%mode lookup-label-eq +X1 +X2 +X3 +X4 +X5 +X6 +X7 +X8 +X9 -X10 -X11.

-     : lookup-label-eq L (expand/arrow OD) LD L' (expand/arrow OD') LD' EQ EQL OG EQS EQU
   <- lookup-eq L L' EQ OG EQA
   <- arrow-eq EQA EQD _ _
   <- dlookup-eq LD LD' EQD OD OD' EQS EQU.

%worlds (ovar) (lookup-label-eq _ _ _ _ _ _ _ _ _ _ _).
%total {}      (lookup-label-eq _ _ _ _ _ _ _ _ _ _ _).


pev-lookup-eq     : pev G X L AS AU
                 -> pev G X L AS' AU'
%%
                 -> tp-eq AS AS'
                 -> tp-eq AU AU'
      -> type.
%mode pev-lookup-eq +X1 +X2 -X3 -X4.

- : pev-lookup-eq
     (pev/a OG L OD LD WU WS B)
     (pev/a OG' L' OD' LD' WU' WS' B')
     EQS EQU
<- lookup-label-eq L OD LD L' OD' LD' exp-eq/i label-eq/i OG EQS EQU.

%worlds (ovar) (pev-lookup-eq _ _ _ _).
%total P (pev-lookup-eq P _ _ _).

extract-sub-decls-one-parts: sub-decls G1 (dcons dnil L AS1 AU1) G2 (dcons dnil L AS2 AU2)
%%
                              -> sub G1 AS1 G1 AU1
                              -> sub G2 AS2 G2 AU2
                              -> sub G2 AS2 G1 AS1
                              -> sub G1 AU1 G2 AU2
                              -> type.
%mode extract-sub-decls-one-parts +X1 -X2 -X3 -X4 -X5.

- : extract-sub-decls-one-parts
     (sub-decls/cons-hit
        dbounded/nil dbounded/nil (sub-decls/nil wf-decls/nil)
        BU12 BS21 B22 B11)
     B11 B22 BS21 BU12.

%worlds (var | ovar) (extract-sub-decls-one-parts _ _ _ _ _).
%reduces B < D (extract-sub-decls-one-parts D B _ _ _).
%reduces B < D (extract-sub-decls-one-parts D _ B _ _).
%reduces B < D (extract-sub-decls-one-parts D _ _ B _).
%reduces B < D (extract-sub-decls-one-parts D _ _ _ B).
%total {} (extract-sub-decls-one-parts _ _ _ _ _).

sub-trans-aux : wft G2 A2
                 -> sub G1 A1 G2 A2
                 -> sub G2 A2 G3 A3
%%
                 -> sub G1 A1 G3 A3
        -> type.
%mode sub-trans-aux +X1 +X2 +X3 -X4.

sub-decls-trans-aux : wf-decls G2 D2
                       -> sub-decls G1 D1 G2 D2
                       -> sub-decls G2 D2 G3 D3
%%
                       -> sub-decls G1 D1 G3 D3
        -> type.
%mode sub-decls-trans-aux +X1 +X2 +X3 -X4.

-/o     : sub-trans-aux wft/o sub/o sub/o sub/o.

-/top   : sub-trans-aux _ B12 (sub/top _) (sub/top W)
     <- extract-wf B12 W _.

-/bot   : sub-trans-aux _ (sub/bot _) B23 (sub/bot W)
     <- extract-wf B23 _ W.

-/arrow : sub-trans-aux
           (wft/arrow (WU: wft G2 U2) (WS: wft G2 S2) WD)
           (sub/arrow (BU12: sub G1 U1 G2 U2) (BS21: sub G2 S2 G1 S1) BD21)
           (sub/arrow (BU23: sub G2 U2 G3 U3) (BS32: sub G3 S3 G2 S2) BD23)
           (sub/arrow (BU13: sub G1 U1 G3 U3) (BS31: sub G3 S3 G1 S1) BD13)
     <- sub-decls-trans-aux WD BD21 BD23 BD13
     <- sub-trans-aux WS BS32 BS21 BS31
     <- sub-trans-aux WU BU12 BU23 BU13.

-/tsel1 : sub-trans-aux
           W
           (sub/tsel1 P B12)
           B23
           (sub/tsel1 P B13)
     <- sub-trans-aux W B12 B23 B13.

-/tsel2 : sub-trans-aux
           W
           B12
           (sub/tsel2 P B23)
           (sub/tsel2 P B13)
     <- sub-trans-aux W B12 B23 B13.

-/tsel21: sub-trans-aux
            (wft/tsel (pev/a OG2 L2 OD2 LD2 WU2 WS2 B2))
            (sub/tsel2
               (pev/a OG2' L2' OD2' LD2' WU2' WS2' B2')
               (B12: sub G1 A1 G2 AS2'))
            (sub/tsel1
               (pev/a OG2'' L2'' OD2'' LD2'' WU2'' WS2'' B2'')
               (B23: sub G2 AU2'' G3 A3))
            (B13: sub G1 A1 G3 A3)
     <- lookup-label-eq L2' OD2' LD2' L2 OD2 LD2 exp-eq/i label-eq/i OG2 SS' SU'
     <- lookup-label-eq L2'' OD2'' LD2'' L2 OD2 LD2 exp-eq/i label-eq/i OG2 SS'' SU''
     <- sub-eq2 SS' B12 B12'
     <- sub-eq1 SU'' B23 B23''
     <- sub-trans-aux WU2 B2 B23'' B23'''
     <- sub-trans-aux WS2 B12' B23''' B13.

-/tselx1: sub-trans-aux
           (wft/tsel (pev/a OG2 L2 OD2 LD2 WU2 WS2 B2))
           (sub/tselx
              (sub-decls/cons-hit
                 dbounded/nil dbounded/nil (sub-decls/nil wf-decls/nil)
                 BU12 BS21 B22 B11)
              _
              (pev/a OGX LX ODX LDX WUX WSX BX)
              SX1
              SX2)
           (sub/tsel1
              (pev/a OG2R L2R OD2R LD2R WU2R WS2R B2R)
              B23)
           (sub/tsel1
              (pev/a OG1' L1' OD1' LD1' WU1' WS1' B1')
              B13)
     <- extend-pev-sub-ctx (pev/a OGX LX ODX LDX WUX WSX BX) SX1 (pev/a OG1' L1' OD1' LD1' WU1' WS1' B1')
     <- extend-pev-sub-ctx (pev/a OGX LX ODX LDX WUX WSX BX) SX2 (pev/a OG2' L2' OD2' LD2' WU2' WS2' B2')
     <- lookup-label-eq L2 OD2 LD2 L2' OD2' LD2' exp-eq/i label-eq/i OG2  EQS2  EQU2
     <- lookup-label-eq L2R OD2R LD2R L2' OD2' LD2' exp-eq/i label-eq/i OG2R EQS2R EQU2R
     <- sub-eq1 EQU2R B23 B23'
     <- wft-eq EQU2 WU2 WU2x
     <- sub-trans-aux WU2x BU12 B23' B13.

-/tsel2x: sub-trans-aux
           (wft/tsel (pev/a OG2 L2 OD2 LD2 WU2 WS2 B2))
           (sub/tsel2
              (pev/a OG2L L2L OD2L LD2L WU2L WS2L B2L)
              B12)
           (sub/tselx
              _
              (sub-decls/cons-hit
                 dbounded/nil dbounded/nil (sub-decls/nil wf-decls/nil)
                 BU23 BS32 B33 B22)
              (pev/a OGX LX ODX LDX WUX WSX BX)
              SX2
              SX3)
           (sub/tsel2
              (pev/a OG3' L3' OD3' LD3' WU3' WS3' B3')
              B13)
     <- extend-pev-sub-ctx (pev/a OGX LX ODX LDX WUX WSX BX) SX2 (pev/a OG2' L2' OD2' LD2' WU2' WS2' B2')
     <- extend-pev-sub-ctx (pev/a OGX LX ODX LDX WUX WSX BX) SX3 (pev/a OG3' L3' OD3' LD3' WU3' WS3' B3')
     <- lookup-label-eq L2  OD2 LD2 L2' OD2' LD2' exp-eq/i label-eq/i OG2  EQS2  EQU2
     <- lookup-label-eq L2L OD2L LD2L L2' OD2' LD2' exp-eq/i label-eq/i OG2L EQS2L EQU2L
     <- sub-eq2 EQS2L B12 B12'
     <- wft-eq EQS2 WS2 WS2x
     <- sub-trans-aux WS2x B12' BS32 B13.

-/tselxx: sub-trans-aux
           (wft/tsel P2)
           ((sub/tselx BD12 BD21 P12 (SX1: sub-ctx G12 G1) (SX2: sub-ctx G12 G2)): sub G1 (tsel X L) G2 (tsel X L))
           ((sub/tselx BD23 BD32 P23 (SX2': sub-ctx G23 G2) (SX3: sub-ctx G23 G3)): sub G2 (tsel X L) G3 (tsel X L))
           ((sub/tselx
               (sub-decls/cons-hit
                  dbounded/nil dbounded/nil (sub-decls/nil wf-decls/nil)
                  BU13 BS31 B33 B11)
               (sub-decls/cons-hit
                  dbounded/nil dbounded/nil (sub-decls/nil wf-decls/nil)
                  BU31 BS13 B11 B33)
               P13 SX1' SX3'): sub G1 (tsel X L) G3 (tsel X L))
      <- extend-pev-sub-ctx P12 SX2 P12'
      <- extend-pev-sub-ctx P23 SX2' P23'
      <- pev-lookup-eq P23' P12' EQS' EQU'
      <- pev-lookup-eq P12' P23' EQS'' EQU''
      <- extract-sub-decls-one-parts BD12 B11 _   BS21 BU12
      <- extract-sub-decls-one-parts BD21 _   _    BS12 BU21
      <- extract-sub-decls-one-parts BD23 _   B33x BS32 BU23
      <- extract-sub-decls-one-parts BD32 _   _    BS23 BU32
      <- pev-lookup-eq P2 P12' EQS EQU
      <- pev-eq EQS EQU P2 P2'
      <- extract-wf-pev-low P2' WS2
      <- extract-wf-pev-high P2' WU2
      <- sub-eq1 EQU' BU23 BU23x
      <- sub-eq2 EQU' BU23x BU23'
      <- sub-eq1 EQS' BS32 BS32x
      <- sub-eq2 EQS' BS32x BS32'
      <- sub-eq1 EQU' BU32 BU32x
      <- sub-eq2 EQU' BU32x BU32'
      <- sub-eq1 EQS' BS23 BS23x
      <- sub-eq2 EQS' BS23x BS23'
      <- sub-trans-aux WU2 BU12 BU23' BU13
      <- sub-trans-aux WS2 BS32' BS21 BS31
      <- sub-trans-aux WU2 BU32' BU21 BU31
      <- sub-trans-aux WS2 BS12 BS23' BS13
      <- pev-eq EQS' EQU' P23 P23x
      <- pev-dia P2' P12 P23x SX2 SX2' P13 SX1x SX3x
      <- sub-ctx-trans SX1x SX1 SX1'
      <- sub-ctx-trans SX3x SX3 SX3'
      <- sub-eq1 EQS' B33x B33xx
      <- sub-eq2 EQU' B33xx B33.

- : sub-decls-trans-aux
     WD2
     BD12
     (sub-decls/nil _)
     (sub-decls/nil WD1)
<- extract-wf-decls BD12 WD1 _.

- : sub-decls-trans-aux
     (wf-decls/cons _ WD2 _ WU2 WS2)
     (sub-decls/cons-hit _   OD1 BD12 BU12 BS21 _   B11)
     (sub-decls/cons-hit OD3 OD2 BD23 BU23 BS32 B33 B22)
     (sub-decls/cons-hit OD3 OD1 BD13 BU13 BS31 B33 B11)
<- sub-decls-trans-aux WD2 BD12 BD23 BD13
<- sub-trans-aux WU2 BU12 BU23 BU13
<- sub-trans-aux WS2 BS32 BS21 BS31.

- : sub-decls-trans-aux
     WD2
     (sub-decls/cons-miss (dbounded/cons _ L21) WD1 BD12)
     (sub-decls/cons-hit OD3 OD2 BD23 BU23 BS32 B33 B22)
     (sub-decls/cons-miss (dbounded/cons OD3 L21) WD1 BD13)
<- sub-decls-trans-aux WD2 BD12 (sub-decls/cons-hit OD3 OD2 BD23 BU23 BS32 B33 B22) BD13.

- : sub-decls-trans-aux
     (wf-decls/cons _ WD2 _ WU2 WS2)
     (sub-decls/cons-hit OD1 OD2 BD12 BU12 BS21 B22 B11)
     (sub-decls/cons-miss OD3 _ BD23)
     (sub-decls/cons-miss OD3 WD1 BD13)
<- extract-wf-decls (sub-decls/cons-hit OD1 OD2 BD12 BU12 BS21 B22 B11) WD1 _
<- sub-decls-trans-aux WD2 BD12 BD23 BD13.

- : sub-decls-trans-aux
     WD2
     (sub-decls/cons-miss (dbounded/cons OD2 L21) WD1 BD12)
     (sub-decls/cons-miss (dbounded/cons OD3 L32) WD2' BD23)
     (sub-decls/cons-miss (dbounded/cons OD3 L31) WD1 BD13)
<- sub-decls-trans-aux WD2 BD12 (sub-decls/cons-miss (dbounded/cons OD3 L32) WD2' BD23) BD13
<- label-less-trans L32 L21 L31.

%worlds (ovar) (sub-trans-aux _ _ _ _) (sub-decls-trans-aux _ _ _ _).
%total {(W2 WD2) (B12 BD12) (B23 BD23)} (sub-trans-aux W2 B12 B23 _) (sub-decls-trans-aux WD2 BD12 BD23 _).

sub-trans   : sub G1 A1 G2 A2
               -> sub G2 A2 G3 A3
%%
               -> sub G1 A1 G3 A3
-> type.
%mode sub-trans +X1 +X2 -X3.

- : sub-trans B12 B23 B13
<- extract-wf B12 W1 W2
<- sub-trans-aux W2 B12 B23 B13.

%worlds (ovar) (sub-trans _ _ _).
%total {} (sub-trans _ _ _).

extend-wfv  : wfv V G B
               -> ordered (cons G X A)
%%
               -> wfv V (cons G X A) B
        -> type.
%mode extend-wfv +X1 +X2 -X3.

-      : extend-wfv wfv/v _ wfv/v.

-      : extend-wfv (wfv/arrow B OG' T WE) OG (wfv/arrow B' OG' T WE)
    <- extend-sub2 B OG B'.

-      : extend-wfv (wfv/bin W WT) OG (wfv/bin W' WT')
    <- extend-wft WT OG WT'
    <- {x}{d:isvar x I} extend-wfv (W x d) OG (W' x d).

-      : extend-wfv (wfv/sub S W) OG (wfv/sub S' W)
    <- extend-sub2 S OG S'.

%worlds (var | ovar) (extend-wfv _ _ _).
%total W (extend-wfv W _ _).

lookup-safe : wfe H G
               -> lookup G X A
               -> vlookup H X V
               -> ordered G
               -> vordered H
%%
               -> wfv V G A
         -> type.
%mode lookup-safe +X1 +X2 +X3 +X4 +X5 -X6.

-       : lookup-safe (wfe/cons WE WV) lookup/hit vlookup/hit OG OH WV'
     <- extend-wfv WV OG WV'.

-       : lookup-safe (wfe/cons WE WV) (lookup/miss LG) (vlookup/miss LH) (ordered/cons BG) (vordered/cons BH) WV''
     <- bounded-is-ordered BG OG
     <- vbounded-is-vordered BH OH
     <- lookup-safe WE LG LH OG OH WV'
     <- extend-wfv WV' (ordered/cons BG) WV''.

-       : lookup-safe (wfe/cons WE (WV: wfv _ _ A)) lookup/hit (vlookup/miss LH) OG (vordered/cons BH) W'
     <- vlookup-vbounded-contra LH BH CONTRA
     <- false-implies-wfv CONTRA (W': wfv _ _ A).

-       : lookup-safe (wfe/cons WE WV) ((lookup/miss LG): lookup _ _ A) vlookup/hit (ordered/cons BG) OH W'
     <- lookup-bounded-contra LG BG CONTRA
     <- false-implies-wfv CONTRA (W': wfv _ _ A).

%worlds (ovar) (lookup-safe _ _ _ _ _ _).
%total W (lookup-safe W _ _ _ _ _).

extract-wfv : wfv V G A
%%
               -> wft G A
   -> type.
%mode extract-wfv +X1 -X2.

-  : extract-wfv wfv/v wft/o.

-  : extract-wfv (wfv/arrow B OG T WE) W'
<- extract-wf B _ W'.

-  : extract-wfv (wfv/bin WV W) W.

-  : extract-wfv (wfv/sub B WV) W'
<- extract-wf B _ W'.

%worlds (ovar) (extract-wfv _ _).
%total W (extract-wfv W _).

invert-b    : of G b A
%%
               -> of G b o
               -> sub G o G A
   -> type.
%mode invert-b +X1 -X2 -X3.

-  : invert-b of/b of/b sub/o.

-  : invert-b (of/sub B T) T' B''
<- invert-b T T' B'
<- sub-trans B' B B''.

%worlds (ovar) (invert-b _ _ _).
%total T (invert-b T _ _).

invert-var  : of G X A
               -> isvar X I
%%
               -> lookup G X A1
               -> sub G A1 G A
   -> type.
%mode invert-var +X1 +X2 -X3 -X4.

-  : invert-var (of/var _ W OG L) D L B
<- sub-refl W B.

-  : invert-var (of/sub B T) D L B''
<- invert-var T D L B'
<- sub-trans B' B B''.

%worlds (ovar) (invert-var _ _ _ _).
%total T (invert-var T _ _ _).

invert-app  : of G (app M N) A
%%
               -> of G M (arrow D A1 A2)
               -> of G N A1
               -> sub G A2 G A
   -> type.
%mode invert-app +X1 -X2 -X3 -X4.

-  : invert-app (of/app TM TN) TM TN B
<- extract-wf-tp (of/app TM TN) W
<- sub-refl W B.

-  : invert-app (of/sub B T) TM TN B''
<- invert-app T TM TN B'
<- sub-trans B' B B''.

%worlds (ovar) (invert-app _ _ _ _).
%total T (invert-app T _ _ _).

sub-either  : ctx -> tp -> ctx -> tp
           -> ctx -> tp -> ctx -> tp
           -> type.
sub-either/left  : sub G A G' A' -> sub-either G A G' A' _ _ _  _.
sub-either/right : sub G A G' A' -> sub-either _ _ _  _  G A G' A'.

sub-either-trans : sub-either
                    G1 A1 G A
                    G2 A2 G A
                    -> sub G A G' A'
%%
                    -> sub-either
                       G1 A1 G' A'
                       G2 A2 G' A'
   -> type.
%mode sub-either-trans +X1 +X2 -X3.

-  : sub-either-trans (sub-either/left S1)  S (sub-either/left S1')
<- sub-trans S1 S S1'.

-  : sub-either-trans (sub-either/right S2) S (sub-either/right S2')
<- sub-trans S2 S S2'.

%worlds (ovar) (sub-either-trans _ _ _).
%total E (sub-either-trans E _ _).

sub-either-wfv : sub-either
                  G1 A1 G A
                  G2 A2 G A
                  -> wfv V G1 A1
                  -> wfv V G2 A2
%%
                  -> wfv V G A
   -> type.
%mode sub-either-wfv +X1 +X2 +X3 -X4.

-  : sub-either-wfv (sub-either/left B)  W1 W2 (wfv/sub B W1).

-  : sub-either-wfv (sub-either/right B) W1 W2 (wfv/sub B W2).

%worlds (ovar) (sub-either-wfv _ _ _ _).
%total E (sub-either-wfv E _ _ _).

invert-lam  : of G (lam D A M) A'
%%
               -> ({x:exp}{d:isvar x I} ordered (cons G x A))
               -> ({x:exp}{d:isvar x I} of (cons G x A) (M x) B)
               -> wft G (arrow D A B)
               -> sub G (arrow D A B) G A'
   -> type.
%mode invert-lam +X1 -X2 -X3 -X4 -X5.

-  : invert-lam (of/lam WT OG T) OG T WT B
<- sub-refl WT B.

-  : invert-lam (of/sub B T) OG' T' WT' B''
<- invert-lam T OG' T' WT' B'
<- sub-trans B' B B''.

%worlds (ovar) (invert-lam _ _ _ _ _).
%total T (invert-lam T _ _ _ _).

inv-arrow-aux : wfv (clo H M) G1 A1
                       -> sub G1 A1 G2 (arrow D2 A2 B2)
%%
                       -> ({x}{d:isvar x I} of (cons G x A) (M x) B)
                       -> wfe H G
                       -> ({x}{d:isvar x I} ordered (cons G x A))
                       -> sub G (arrow D A B) G2 (arrow D2 A2 B2)
   -> type.
%mode inv-arrow-aux +X1 +X2 -X3 -X4 -X5 -X6.

-  : inv-arrow-aux (wfv/arrow BC1 OG T WE) B12 T WE OG BC2
<- sub-trans BC1 B12 BC2.

-  : inv-arrow-aux (wfv/sub BC1 W1) B12 T' WE' OG' BC2'
<- sub-trans BC1 B12 BC2
<- inv-arrow-aux W1 BC2 T' WE' OG' BC2'.

%worlds (ovar) (inv-arrow-aux _ _ _ _ _ _).
%total W (inv-arrow-aux W _ _ _ _ _).

inv-arrow   : wfv (clo H M) G2 (arrow D2 A2 B2)
%%
               -> ({x}{d:isvar x I} of (cons G x A) (M x) B)
               -> wfe H G
               -> ({x}{d:isvar x I} ordered (cons G x A))
               -> sub G (arrow D A B) G2 (arrow D2 A2 B2)
   -> type.
%mode inv-arrow +X1 -X2 -X3 -X4 -X5.

-  : inv-arrow W T WE OG S
<- extract-wfv W WT
<- sub-refl WT B
<- inv-arrow-aux W B T WE OG S.

%worlds (ovar) (inv-arrow _ _ _ _ _).
%total W (inv-arrow W _ _ _ _).

inv-bin-aux   :  wfv (bin V) G1 A1
               -> sub G1 A1 G2 A2
%%
               -> wft G A
               -> ({x}{d:isvar x I} wfv (V x) G A)
               -> sub G A G2 A2
   -> type.
%mode inv-bin-aux +X1 +X2 -X2 -X3 -X4.

-  : inv-bin-aux (wfv/bin WV WT) B WT WV B.

-  : inv-bin-aux (wfv/sub BC1 W) B12 WT' WV' BC2'
<- sub-trans BC1 B12 BC2
<- inv-bin-aux W BC2 WT' WV' BC2'.

%worlds (ovar) (inv-bin-aux _ _ _ _ _).
%total W (inv-bin-aux W _ _ _ _).

inv-bin      :  wfv (bin V) G2 A2
%%
               -> wft G A
               -> ({x}{d:isvar x I} wfv (V x) G A)
               -> sub G A G2 A2
   -> type.
%mode inv-bin +X1 -X2 -X3 -X4.

-  : inv-bin W WT WV S
<- extract-wfv W WT'
<- sub-refl WT' B
<- inv-bin-aux W B WT WV S.

%worlds (ovar) (inv-bin _ _ _ _).
%total W (inv-bin W _ _ _).

inv-bin-arrow-aux :  wfv (bin V) G1 A1
                     -> sub G1 A1 G2 (arrow D2 S2 U2)
%%
                     -> wft G (arrow D S U)
                     -> ({x}{d:isvar x I} wfv (V x) G (arrow D S U))
                     -> sub G (arrow D S U) G2 (arrow D2 S2 U2)
   -> type.
%mode inv-bin-arrow-aux +X1 +X2 -X2 -X3 -X4.

-  : inv-bin-arrow-aux (wfv/bin WV WT) B WT' ([x][d:isvar x I] (wfv/sub B (WV x d))) BR
<- extract-wf B _ WT'
<- sub-refl WT' BR.

-  : inv-bin-arrow-aux (wfv/sub BC1 W) B12 WT' WV' BC2'
<- sub-trans BC1 B12 BC2
<- inv-bin-arrow-aux W BC2 WT' WV' BC2'.

%worlds (ovar) (inv-bin-arrow-aux _ _ _ _ _).
%total W (inv-bin-arrow-aux W _ _ _ _).

inv-bin-arrow     :  wfv (bin V) G2 (arrow D2 S2 U2)
%%
                     -> wft G (arrow D S U)
                     -> ({x}{d:isvar x I} wfv (V x) G (arrow D S U))
                     -> sub G (arrow D S U) G2 (arrow D2 S2 U2)
   -> type.
%mode inv-bin-arrow +X1 -X2 -X3 -X4.

-  : inv-bin-arrow W WT WV S
<- extract-wfv W WT'
<- sub-refl WT' B
<- inv-bin-arrow-aux W B WT WV S.

%worlds (ovar) (inv-bin-arrow _ _ _ _).
%total W (inv-bin-arrow W _ _ _).

ev-safe     : of G M A
               -> wfe H G
               -> ordered G
               -> vordered H
               -> ev H M V
%%
               -> wfv V G A
    -> type.
%mode ev-safe +X1 +X2 +X3 +X4 +X5 -X6.

evapp-safe  : wfv VFUN G (arrow D A1 A2)
               -> wfv VARG G A1
               -> evapp VFUN VARG V
%%
               -> wfv (bin V) G A2
    -> type.
%mode evapp-safe +X1 +X2 +X3 -X4.

-   : ev-safe T WE OG OH ev/b (wfv/sub B wfv/v)
 <- invert-b T T' B.

-   : ev-safe T WE OG OH (ev/var LH) (wfv/sub B WV)
 <- vlookup-vordered LH OH D
 <- invert-var T D LG B
 <- lookup-safe WE LG LH OG OH WV.

-   : ev-safe T WE OG OH ev/lam (wfv/sub BE (wfv/arrow B OG' TM WE))
 <- invert-lam T OG' TM W BE
 <- sub-refl W B.

-   : ev-safe T WE OG OH (ev/app EVAPP EVARG EVFUN) (wfv/sub B W)
 <- invert-app T TFUN TARG B
 <- ev-safe TARG WE OG OH EVARG WARG
 <- ev-safe TFUN WE OG OH EVFUN WFUN
 <- evapp-safe WFUN WARG EVAPP W.

-   : evapp-safe W (WARG: wfv _ G' _) (evapp/clo EV) (wfv/bin ([x][d:isvar x I] (wfv/sub (BU' x d) (W'' x d))) WT')
 <- inv-arrow W TFUN (WE: wfe H G) OG (sub/arrow BU BS D)
 <- ({x}{d:isvar x I} ordered-to-vordered (wfe/cons WE (wfv/sub BS WARG)) (OG x d) (OH x d))
 <- ({x}{d:isvar x I}
       ev-safe
       (TFUN x d)
       (wfe/cons WE (wfv/sub BS WARG))
       (OG x d)
       (OH x d)
       (EV x)
       (W'' x d))
 <- extract-wf BU _ WT'
 <- ({x}{d:isvar x I} extend-sub1 BU (OG x d) (BU' x d)).

-   : evapp-safe W0 WARG (evapp/bin EV) (wfv/bin ([x][d:isvar x I] (wfv/sub BU (W' x d))) WT')
 <- inv-bin-arrow W0 (wft/arrow WU WS WD) W (sub/arrow BU BS BD)
 <- ({x}{d:isvar x I} evapp-safe (W x d) (wfv/sub BS WARG) (EV x) (W' x d))
 <- extract-wf BU _ WT'.

%worlds (ovar) (ev-safe _ _ _ _ _ _) (evapp-safe _ _ _ _).
%total  (A B)  (ev-safe _ _ _ _ A _) (evapp-safe _ _ B _).
